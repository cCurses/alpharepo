#!/bin/bash
#+ marker sof +#

# scanfs v2019.10.01+

# Copyright (C) 2019
# Erik Jan Tromp <alphageek@slackware.com>
# Licensed under the GPL v2

# concept:
# - scan the named filesystem segment(s) & report findings in various formats
# - optionally unlink files that were previously hardlinked

# TODO:
# - whatinhell did I break? the error trap is not entered *at all* when ^C is
#   pressed. first & foremost, this obviously needs figuring out. HELP!
# > for now. do *NOT* abort the script when it's unlinking files & everything
#   will be tickety-boo

# - wrap all the test code scattered throughout the script in
#   _BOOLEAN_TESTING_01 (numbered in case I need more of them) so the mess I'm
#   making can stay & be easily found, but the script's normal usage wil not
#   be affected (done)
#_BOOLEAN_TESTING_01=false # disabled
#
_BOOLEAN_TESTING_01=true # enabled
# > at present. all 8 are in "function _pathnames_scan" & are only visible in
#   "verbose" mode. look for "1/8" to "8/8". 6 in the loop. 2 after the loop

# - "function _trap" needs attention. it correctly deletes the temp file, but
#   it restores an incorrect timestamp from I know not where (current time?)
# * (or maybe the temp file doesn't even exist. explore this idea later)
# > figure out what I'm doing wrong in the error trap. test code is here:
#   #+ marker trap test +# / #- marker trap test -#
# > currently only in "function _trap_test"

# > live (unaltered) code is here:
#   #+ marker trap live +# / #- marker trap live -#

# > test code is enabled. to disable it simply rename the following:
# from: #trap _trap SIGINT SIGTERM
# from: trap _trap_test SIGINT SIGTERM
#   to: trap _trap SIGINT SIGTERM
#   to: #trap _trap_test SIGINT SIGTERM
#trap#

# - create a directory/file hierarchy (as root, obviously) with entries owned
#   by everyone listed in /etc/passwd & /etc/group to test assorted features
# > one thought comes immediately to mind: assuming permissions permit it,
#   as non-root, unlink files owned by someone else & see what happens

# - ensure the changelog has been accurately updated. that'll be fun :(

# - remove select portions of the script that have been #'d out (done?)

# - remove the following headers/footers & the conditional wraps within each:
#   #+ marker *sum conflict size +# / #- marker *sum conflict size -#
#   #+ marker *sum conflict type +# / #- marker *sum conflict type -#
#   #+ marker *sum dry-run +# / #- marker *sum dry-run -#
#   #+ marker edit +# / #- marker edit -#
#   #disabled# < keep this one (useful for testing)

# TODO:
# - possibly use printf elsewhere (everywhere?) (verbose output for settings?)
# ^ this will require a complete rethink of how _eko_v currently does things
# - alternate approach: define _eko_pv (verbose via printf) & use that for
#   special occasions (done)

# TODO:
# - figure out hardlinking
# - the first & greatest hurdle is coming up with an *efficient* method of
#   populating an sqlite3 db (aka: as fast as possible while retaining 100%
#   accuracy) during the filesystem scan in "function _pathnames_scan". once
#   that is solved, everything else will fall into place
# - shitwall some of the ideas that have been suggested by others. at the very
#   least, having a properly populated sqlite3 db (regardless of how
#   inefficiently it is generated) will provide me with the required data to
#   work on the routine(s) that would follow. all of this can be done in
#   standalone script snippets for testing so there's no need to retain the
#   sqlite3 stub in this script

# 2019-10-06
# - changed the following lines throughout the script:
#  was: _eko_v "      \$_FOO: \"$_FOO\""
#   is: _eko_pv "\$_FOO:" \""$_FOO\""
# - "function _eko_pv" added for properly formatted verbose output
# 2019-10-01
# - "function _pathnames_scan" added/changed the following lines:
#  add: # - 4: "$_MY_GID" for additional finger pointing :)
#  was: # - 4: "$PPID" for a degree of uniqueness coupled with the
#   is: # - 5: "$PPID" for a degree of uniqueness coupled with the
#  was: # - 5: "$$" for an additional degree of uniqueness in case the user
#   is: # - 6: "$$" for an additional degree of uniqueness in case the user
#  was: _SU_NAME="${_ST_NAME}.scanfs.$_MY_UID.$PPID.$$"
#   is: _SU_NAME="${_ST_NAME}.scanfs.$_MY_UID:$_MY_GID.$PPID.$$"
#  was: printf "%4s %10s %s %4s %4s %3s %14s %s %s %s %s %s\n" \
#   is: printf "%4s %10s %s %4s %4s %-3s %14s %s %s %s %s %s\n" \
#  was: printf "%4s %10s %s %4s %4s %3s %14s %s %s %s %s\n" \
#   is: printf "%4s %10s %s %4s %4s %-3s %14s %s %s %s %s\n" \
# - performed simple timing tests of the various *sum routines to get a rough
#   idea of their relative performance. kept the raw information in the script
#   for future reference. look for the following tags:
#   #+ marker binary size/speed +# / #- marker binary size/speed -#
# - "function _sqlite3_test" removed. until I get that much anticipated "AHA!"
#   moment regarding *efficiently* populating the db with potentially millions
#   of files, this unused function is just useless clutter
#   (NOTE: the function is removed, but the requisite logic is retained)
# - "function _show_help" changed the following lines:
#  was:             additive: \"-p\"
#  was: last invocation used: \"-s\"
#  was:               toggle: \"-D -E -H -N -S -U -d -l -m -n -r -v -x\"
#   is:          additive: \"-p\"
#   is:            toggle: \"-D -E -H -N -S -U -d -l -n -r -v -x\"
#   is: single invocation: \"-m -1 -224 -256 -384 -512, -s\"
# - "function _parse_parameters" added logic for dealing with *sum size
#   conflicts. the new routine is wrapped in the following tags temporarily:
#   #+ marker *sum conflict size +# / #- marker *sum conflict size -#
# - "function _parse_parameters" added logic for dealing with *sum type
#   conflicts. the new routines are wrapped in the following tags temporarily:
#   #+ marker *sum conflict type +# / #- marker *sum conflict type -#
# - overall cosmetic cleanup of the entire script. there are entirely too many
#   small changes to list everything.
# - "function _parse_parameters" added the following variable:
#  add: _BOOLEAN_SUM
# ^ it's a catch-all variable for use in "function _pathnames_scan" to signify
#   that one of the many *sum routines should be called
# - added the following functions:
#  add: function _pathname_openssl_sha1sum()
#  add: function _pathname_openssl_sha224sum()
#  add: function _pathname_openssl_sha256sum()
#  add: function _pathname_openssl_sha384sum()
#  add: function _pathname_openssl_sha512sum()
#  add: function _pathname_sha1sum_sha1sum()
#  add: function _pathname_sha224sum_sha224sum()
#  add: function _pathname_sha256sum_sha256sum()
#  add: function _pathname_sha384sum_sha384sum()
#  add: function _pathname_sha512sum_sha512sum()
# - "function _show_help" reordered the option/description list to group the
#   various *sum routines together
# - "function _show_help" added the following lines:
#  add: -1, --sha1sum       Generate an sha1sum for each file
#  add: -224, --sha224sum   Generate an sha224sum for each file
#  add: -256, --sha256sum   Generate an sha256sum for each file
#  add: -384, --sha384sum   Generate an sha384sum for each file
#  add: -512, --sha512sum   Generate an sha512sum for each file
# - "function _show_help" changed the following line:
#  was: -s, --size          Specify the maximum \""head\"" size of each file to md5sum
#   is: -s, --size          Specify the maximum \""head\"" size of each file to *sum
# - "function _pathname_md5sum_md5sum" & "function _pathname_openssl_md5sum"
#   changed the following lines:
#  was: # - generate md5sum of the file (full)
#   is: # - generate *sum of the file (full)
#  was: # - generate md5sum of the file ($_OPTION_SUM_SIZE)
#   is: # - generate *sum of the file ($_OPTION_SUM_SIZE)
# - changed the following line in "function _pathnames_scan"
#  was: # - generate md5sum of the file (full or $_OPTION_SUM_SIZE)
#   is: # - generate *sum of the file (full or $_OPTION_SUM_SIZE)
# - renamed the following variables globally:
#  was: _FUNCTION_MD5SUM
#   is: _FUNCTION_SUM
#  was: _OPTION_MD5SUM_SIZE
#   is: _OPTION_SUM_SIZE
#  was: _ST_MD5
#   is: _ST_SUM
# - renamed the following function globally:
#  was: _pathname_md5sum_openssl
#   is: _pathname_openssl_md5sum
# ^ the renamings listed above have deliberately *not* been done in the
#   changelog entries. only in the "live" code
# 2019-09-28
# - "function _pathnames_scan" replaced the usage of "echo" with "printf" in
#   the "stdout" & "verbose" output modes, following the example set by the
#   "long" output mode. there is no change in performance, but it does make
#   future maintenance simpler
# - "function _pathname_md5sum_md5sum" added doublequote wraps (100% required)
#  was: _ST_MD5=${_ST_MD5/%  $_ST_NAME/}
#   is: _ST_MD5=${_ST_MD5/%  "$_ST_NAME"/}
# - "function _pathname_md5sum_openssl" added doublequote wraps (100% required)
#  was: _ST_MD5=${_ST_MD5/#MD5($_ST_NAME)= /}
#   is: _ST_MD5=${_ST_MD5/#MD5("$_ST_NAME")= /}
# 2019-09-18
# - altered all 3 invocations of "read" as follows:
#  was: while read -r -- \
#   is: while read $_OPTIONS_READ -- \
# - "function _builtin_validate_setup" added "read" for "-r"
# 2019-09-17
# - "function _builtin_validate_setup" & "function _binary_validate_setup"
#   altered the "cd"/"pwd", "realpath", & "basename"/"dirname" tests for
#   setting _FUNCTION_TRANSFORM. formerly a confusing mix of nested &
#   sequential, currently ranked sequential
# - "function _binary_validate_setup" altered the "md5sum" & "openssl" tests
#   for setting _FUNCTION_MD5SUM. formerly nested, currently ranked sequential
# - "function _binary_validate_setup" made the following changes to "head",
#   "sort", & "touch" (respectively) so this script can be used with older
#   versions of bash. (technically only required for the "head" test because
#   of the "[" & "]" in the _BINARY_OPTION setup & test, but did all 3 for
#   uniformity)
#  add: _BINARY_HELP=${_BINARY_HELP//=/ }
#  was: _BINARY_OPTION=--bytes=[-]NUM
#   is: _BINARY_OPTION=--bytes
#  add: _BINARY_HELP=${_BINARY_HELP//=/ }
#  was: _BINARY_OPTION=--key=KEYDEF
#   is: _BINARY_OPTION=--key
#  add: _BINARY_HELP=${_BINARY_HELP//=/ }
#  was: _BINARY_OPTION=--date=STRING
#   is: _BINARY_OPTION=--date
# - added "--" to all invocations of "basename", "cd", "cp", "dirname",
#   "head", "md5sum", "mv", "pwd", "read", "realpath", & "rm". possibly
#   overkill in a few spots, but better to have too many than too few
# ^ NOTE: (to self) don't forget "ln" when the time comes
# - "function _pathname_md5sum_md5sum" tested 3 approaches to acquire md5sums
#   of "-s, --size" bytes of files. results:
# 1 fastest & functional. retained:
#   _ST_MD5=$(head --bytes=$_OPTION_MD5SUM_SIZE -- "$_ST_NAME" 2>/dev/null | md5sum -- -)
#   _ST_MD5=${_ST_MD5/%  -/}
# 2 slower & functional. discarded:
#   _ST_MD5=$(md5sum -- <(head --bytes=$_OPTION_MD5SUM_SIZE -- "$_ST_NAME" 2>/dev/null) 2>/dev/null)
#   _ST_MD5=${_ST_MD5/%  \/dev\/fd\/*/}
# 3 slowest & functional. discarded:
#   _ST_MD5=$(md5sum -- < <(head --bytes=$_OPTION_MD5SUM_SIZE -- "$_ST_NAME" 2>/dev/null) 2>/dev/null)
#   _ST_MD5=${_ST_MD5/%  -/}
# - "function _pathname_md5sum_openssl" tested 3 approaches to acquire md5sums
#   of "-s, --size" bytes of files. results:
# 1 fastest & functional. retained:
#   _ST_MD5=$(head --bytes=$_OPTION_MD5SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -md5)
#   _ST_MD5=${_ST_MD5/#(stdin)= /}
# 2 slower & functional. discarded:
#   _ST_MD5=$(openssl dgst -md5 <(head --bytes=$_OPTION_MD5SUM_SIZE -- "$_ST_NAME" 2>/dev/null) 2>/dev/null)
#   _ST_MD5=${_ST_MD5/#MD5(\/dev\/fd\/*)= /}
# 3 slowest & functional. discarded:
#   _ST_MD5=$(openssl dgst -md5 < <(head --bytes=$_OPTION_MD5SUM_SIZE -- "$_ST_NAME" 2>/dev/null) 2>/dev/null)
#   _ST_MD5=${_ST_MD5/#(stdin)= /}
# - removed most #'d lines dealing with unnecessary doublequoting & disabled
#   routines
# - NOTE: (to self) refer to the 2019-09-14 savepoint for the "before" version
# 2019-09-14
# - "function _binary_validate_setup" & "function _builtin_validate_setup" 
#   added calls to "function _eko_v" for variables that are explicitly assigned
# - explicitly unset specific key variables in "setup" that are later set in
#   "function _binary_validate_setup", "function _builtin_validate_setup", &
#   "function _pathnames_scan" for safety
# - "function _pathnames_scan" altered calling syntax to "find". read very
#   carefully. these simple changes make scanning ~20% faster
#  was: <<< \
#  was: "$(find "$_SU_NAME" \
#   is: < \
#   is: <(find "$_SU_NAME" \
#  was: -printf "%D %i %M %n %U %G %s %TY-%Tm-%Td %TH:%TM:%TS %TZ\n" 2>/dev/null)"
#   is: -printf "%D %i %M %n %U %G %s %TY-%Tm-%Td %TH:%TM:%TS %TZ\n" 2>/dev/null)
#  was: <<< \
#  was: "$(find "$_SD_NAME" \
#   is: < \
#   is: <(find "$_SD_NAME" \
#  was: | sort --key=11)"
#   is: | sort --key=11)
#  was: <<< \
#  was: "$(find "${_ARRAY_PATHNAMES[@]}" \
#   is: < \
#   is: <(find "${_ARRAY_PATHNAMES[@]}" \
#  was: | sort --key=4)"
#   is: | sort --key=4)
# 2019-09-12
# - "function _pathname_transform_cd_pwd" added & ranked testing order (1/3)
# - "function _pathname_transform_realpath" ranked testing order (2/3)
# - "function _pathname_transform_bruteforce" ranked testing order (3/3)
# - "function _builtin_validate_setup" added for "cd -P" & "pwd -P"
# - "function _pathname_validate" updated to correctly decipher the pathname
#   if the last element is a symlink
# 2019-08-13
# - "-n, --nanoseconds" option added. it's for use with the "-l, --long" &
#   "-v, --verbose" options
# 2019-08-11
# - "function _binary_validate_setup" altered _BINARY_HELP assignment & tests
#   for each binary
#  was: _BINARY_HELP=$(echo $($_BINARY_NAME --help 2> /dev/null))
#   is: _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
#  was: _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1 /dev/null))
#   is: _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
#  was: if [[ -z $_BINARY_HELP ]]
#   is: if [[ $_BINARY_HELP =~ "command not found" ]]
# - "function _binary_validate_setup" reverted how multiple options are
#   appended to each binary's option list
#  was: _OPTIONS_FOO=${_OPTIONS_FOO/%/ $_BINARY_OPTION}
#   is: _OPTIONS_FOO+=" "$_BINARY_OPTION
# - "function _parse_parameters" altered how paths are appended to the arrays
#  was: _ARRAY_HOLDNAMES=( "${_ARRAY_HOLDNAMES[@]}" "$2" )
#   is: _ARRAY_HOLDNAMES+=( "$2" )
#  was: _ARRAY_PATHNAMES=( "${_ARRAY_PATHNAMES[@]}" "$_OPTION_PATHNAME" )
#   is: _ARRAY_PATHNAMES+=( "$_OPTION_PATHNAME" )
# 2019-08-08
# - "-V, --version-sort" & "-o, --ordered" options removed & what was
#   "-o, --ordered" is now hardcoded. why? version sorted & unordered listings
#   served no real purpose other than as curiosities. additionally, processing
#   time is virtually identical with all forms
# - "function _binary_validate_setup" removed "cat"
# 2019-07-28
# - undo as much of the "wrap everything in doublequotes" nonsense as
#   possible. there are select cases where doublequotes are retained, but
#   *not* everywhere
# - "function _binary_validate_setup" altered how multiple options are
#   appended to each binary's option list
#  was: _OPTIONS_FOO+=" "$_BINARY_OPTION
#   is: _OPTIONS_FOO=${_OPTIONS_FOO/%/ $_BINARY_OPTION}
# ^ this also makes it possible to *prepend* options quite easily. example:
#       _OPTIONS_FOO=${_OPTIONS_FOO/#/$_BINARY_OPTION }
# - more doublequote wraps ( _STRING_PATHNAME ) (not sure about this one)
# 2019-07-27
# - "function _trap" improved the conditional tests to explicitly handle
#   cleanup only if unlinking is interrupted
# 2019-07-25
# - "function _binary_validate_setup" added "rm"
# - "function _trap" added
# - more doublequote wraps ( _LHS _RHS )
# 2019-07-23
# - "-V, --version-sort" option added. refer to sort(1) for specifics
# 2019-07-22
# - "function _binary_validate_setup" altered calling syntax to "sort"
#  was: _OPTIONS_SORT_DIRECTORIES="sort +3"
#  was: _OPTIONS_SORT_FILES="sort +10"
#   is: _OPTIONS_SORT_DIRECTORIES="sort --key=4"
#   is: _OPTIONS_SORT_FILES="sort --key=11"
# - "function _binary_validate_setup" added "--key" test to "sort"
# 2019-07-21
# - "function _pathname_md5sum_md5sum", "function _pathname_md5sum_openssl", &
#   "function _pathnames_scan" experimented with replacing usage of pipes with
#   using "<(commandlist)" (careful: no space between "<" & "("). counter to
#   expectations, the "<(commandlist)" form is *slower* than "| commandlist"
#   by roughly a factor of 2 in "function _pathnames_scan"
# ^ additional "2>/dev/null" & _ST_MD5 massaging in each md5sum function
# 2019-07-18
# - "function _binary_validate_setup" improved "head" test
# - wrap anything & everything involved with calling standalone binaries or
#   bash builtins in doublequotes
# - wrap anything & everything involved with $_OPTION_PATHNAME in doublequotes
#   ( _ARRAY_HOLDNAMES 2 _ARRAY_PATHNAMES _SD_NAME _ST_NAME _SU_NAME )
# 2019-07-12
# - additional style changes:
#   (my scripts are already bash specific, so backwards compatibility is not
#   an issue. several ideas are from http://mywiki.wooledge.org/BashFAQ)
#   - naming convention for functions
#   - usage of "[]" vs "[[]]" to evaluate expressions
#   - doublequote variable assignments only when absolutely necessary to avoid
#     typecasting
# 2019-07-??
# - major edits (too many things to enumerate)
# - edits are ongoing, hence the "??" in the date
# - "function _binary_validate_setup" added "cat", "date", "id", "ln", "mv",
#   "sort", "touch"
# 2019-06-??
# - "function _binary_validate_setup" added for "basename", "cp", "date",
#   "dirname", "find", "head", "md5sum", "openssl", "realpath"
# 2019-05-11
# - start of project

# NOTE:
# - this is a snippet designed for my upcoming project "hardlink" (an absolute
#   & complete rewrite of the tcl original)
# - unfortunately, it appears this will not happen. why? in tcl, it's possible
#   to open a persistent connection to the db, perform as many actions as are
#   required, *then* close the db. the standalone "sqlite3" binary appears to
#   be incapable of this. open once, perform a single action (or a small
#   number of actions), then close. rinse & repeat. this is *not* practical
#   when dealing with large numbers of files (ie: thousands or millions)
# - addendum #1: this might be possible after all. what you see here are
#   various attempts to get it right. I suspect it will be incredibly slow for
#   larger filesets, but it *will* work
# - addendum #2: unlinking files is now 100% functional, complete with
#   preservation of all stat(2) information except (obviously) link counts.
#   for added fun, though the initial filesystem scan itself is slower than
#   the tcl original, the actions required for unlinking files are *faster*

# NOTE:
# - on the bright side, this script can be used to generate a list of md5sums
#   suitable for use with "md5sum -c". the calling syntax is quite simple.
#   use either:
#   "scanfs -p <PathName> -m > checksums.md5" to generate md5sums using the
#   absolute pathname of each regular file in <PathName>
#   or:
#   "scanfs -p <PathName> -m -r > checksums.md5" to generate md5sums using the
#   relative pathname of each regular file in <PathName>

# NOTE:
# - the fraction-of-second portion of timestamps are written to the filesystem
#   as nanoseconds. find's "-printf" option "%TS" simply presents the
#   0-padded value directly as 10 decimal digits. in contrast, ls's
#   "--full-time" option removes the trailing 0 to present 9 decimal digits
#   for human readability

# TODO:
# - allow for regular files to be specified with "-p, --pathname"
# - much *much* later, if ever. probably never

# NOTE: (to self) (& others, if you're bored. hi there!)
# - look for anything with the following tags: EDIT FIXME IDEA NOTE ORDER TODO
#   TRY
# - use of bash builtins is often (but not always) preferred over shelling out
#   to binaries
# ^ reasons: speed, availability, simplicity, & predictability. fast is always
#   preferred, no need to test if a binary even *exists*, no need to be
#   concerned about changed syntax or output from one release to the next

# NOTE: (builtin/binary/variable/function indentation)
# - 2 spaces, hash, binary/variable/function name = in function
# - 0 spaces, hash, binary/variable/function name = in main
# NOTE: (system builtin use & abuse)
  # cd (in combination with pwd, fallback to basename/dirname/find/realpath)
  # pwd (in combination with cd, fallback to basename/dirname/find/realpath)
  # read
# NOTE: (system binary use & abuse)
  # basename (fallback with dirname/find to realpath)
  # cp
  # dirname (fallback with basename/find to realpath)
  # find
  # head
  # id
  # ln
  # md5sum
  # mv
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)
  # realpath
  # rm
  # sha1sum
  # sha224sum
  # sha256sum
  # sha384sum
  # sha512sum
  # sort
  # touch
# NOTE: (system & script variable use & abuse)
# - system variables are always in the form "FOO"
# - script variables are always in the form "_FOO"
# - system variables referenced & modified. necessary & the whole point
  # @
# LC_ALL
# TZ
# - system variables referenced but not modified
  # #
  # $$
  # 1
  # 2
  # @
  # FUNCNAME (single dimension indexed array)
  # PPID
# @
# - ephemeral variables. here today, gone tomorrow (keeping track for myself)
# - better to have too many than too few
  # _ARRAY_ELEMENT_HN (counter)
  # _ARRAY_ELEMENT_PN (counter)
  # _ARRAY_HOLDNAMES (single dimension indexed array)
  # _ARRAY_PATHNAMES (single dimension indexed array)
  # _BASENAME
  # _BINARY_HELP
  # _BINARY_NAME
  # _BINARY_OPTION
  # _BOOLEAN_DEBUG
  # _BOOLEAN_DRYRUN
  # _BOOLEAN_ERROR
  # _BOOLEAN_HARDLINK
  # _BOOLEAN_LONG
  # _BOOLEAN_MD5SUM
  # _BOOLEAN_NANOSECONDS
  # _BOOLEAN_NONSPARSE
  # _BOOLEAN_RELATIVE
  # _BOOLEAN_SHA1SUM
  # _BOOLEAN_SHA224SUM
  # _BOOLEAN_SHA256SUM
  # _BOOLEAN_SHA384SUM
  # _BOOLEAN_SHA512SUM
  # _BOOLEAN_SPARSE
  # _BOOLEAN_STDOUT
  # _BOOLEAN_SUM
  # _BOOLEAN_TIMESTAMP
  # _BOOLEAN_UNLINK
  # _BOOLEAN_VERBOSE
  # _BOOLEAN_XDEV
  # _BUILTIN_HELP
  # _BUILTIN_NAME
  # _BUILTIN_OPTION
  # _DIRNAME
  # _FUNCTION_SUM (_pathname_md5sum_md5sum _pathname_openssl_md5sum _pathname_openssl_sha1sum _pathname_openssl_sha224sum _pathname_openssl_sha256sum _pathname_openssl_sha384sum _pathname_openssl_sha512sum _pathname_sha1sum_sha1sum _pathname_sha224sum_sha224sum _pathname_sha256sum_sha256sum _pathname_sha384sum_sha384sum _pathname_sha512sum_sha512sum)
  # _FUNCTION_TRANSFORM (_pathname_transform_bruteforce _pathname_transform_cd_pwd _pathname_transform_realpath)
  # _LHS
  # _LINKNAME
  # _LLEN
  # _MIN_LEN
  # _MY_GID
  # _MY_UID
  # _OPTIONS_CD (cd options, not script options)
  # _OPTIONS_CP (cp options, not script options)
  # _OPTIONS_LN (ln options, not script options)
  # _OPTIONS_MV (mv options, not script options)
  # _OPTIONS_PWD (pwd options, not script options)
  # _OPTIONS_READ (read options, not script options)
  # _OPTIONS_READWRITE (find options. not script options)
  # _OPTIONS_REALPATH (realpath options, not script options)
  # _OPTIONS_RM (rm options, not script options)
  # _OPTIONS_UIDGID (find options. not script options)
  # _OPTIONS_UNLINK (find options. not script options)
  # _OPTIONS_XDEV (find options. not script options)
  # _OPTION_PATHNAME
  # _OPTION_SUM_SIZE
  # _RHS
  # _RLEN
  # _SD_MTIM_HMS (contrivance. not from stat(2))
  # _SD_MTIM_UTC (contrivance. not from stat(2))
  # _SD_MTIM_YMD (contrivance. not from stat(2))
  # _SD_NAME (contrivance. not from stat(2))
  # _STRING_PATHNAME
  # _ST_DEV
  # _ST_GID
  # _ST_INO
  # _ST_MODE
  # _ST_MTIM_HMS (contrivance. not from stat(2))
  # _ST_MTIM_UTC (contrivance. not from stat(2))
  # _ST_MTIM_YMD (contrivance. not from stat(2))
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_NLINK
  # _ST_SIZE
  # _ST_SUM (contrivance. not from stat(2))
  # _ST_UID
  # _SU_NAME (contrivance. not from stat(2))
# _ARRAY_HOLDNAMES (single dimension indexed array)
# _ARRAY_PATHNAMES (single dimension indexed array)
# _FUNCTION_SUM (_pathname_md5sum_md5sum _pathname_openssl_md5sum _pathname_openssl_sha1sum _pathname_openssl_sha224sum _pathname_openssl_sha256sum _pathname_openssl_sha384sum _pathname_openssl_sha512sum _pathname_sha1sum_sha1sum _pathname_sha224sum_sha224sum _pathname_sha256sum_sha256sum _pathname_sha384sum_sha384sum _pathname_sha512sum_sha512sum)
# _FUNCTION_TRANSFORM (_pathname_transform_bruteforce _pathname_transform_cd_pwd _pathname_transform_realpath)
# _MY_GID
# _MY_UID
# _OPTIONS_CD (cd options, not script options)
# _OPTIONS_CP (cp options, not script options)
# _OPTIONS_LN (ln options, not script options)
# _OPTIONS_MV (mv options, not script options)
# _OPTIONS_PWD (pwd options, not script options)
# _OPTIONS_REALPATH (realpath options, not script options)
# _OPTIONS_READ (read options, not script options)
# _OPTIONS_READWRITE (find options. not script options)
# _OPTIONS_RM (rm options, not script options)
# _OPTIONS_UIDGID (find options. not script options)
# _OPTIONS_UNLINK (find options. not script options)
# _OPTIONS_XDEV (find options. not script options)
# NOTE: (script function use & abuse)
# - script functions are always in the form "_foo"
  # _binary_validate_setup
  # _builtin_validate_setup
  # _eko_iod
  # _eko_pv
  # _eko_v
  # _pathname_md5sum_md5sum (_FUNCTION_SUM)
  # _pathname_openssl_md5sum (_FUNCTION_SUM)
  # _pathname_openssl_sha1sum (_FUNCTION_SUM)
  # _pathname_openssl_sha224sum (_FUNCTION_SUM)
  # _pathname_openssl_sha256sum (_FUNCTION_SUM)
  # _pathname_openssl_sha384sum (_FUNCTION_SUM)
  # _pathname_openssl_sha512sum (_FUNCTION_SUM)
  # _pathname_redundant_check
  # _pathname_sha1sum_sha1sum (_FUNCTION_SUM)
  # _pathname_sha224sum_sha224sum (_FUNCTION_SUM)
  # _pathname_sha256sum_sha256sum (_FUNCTION_SUM)
  # _pathname_sha384sum_sha384sum (_FUNCTION_SUM)
  # _pathname_sha512sum_sha512sum (_FUNCTION_SUM)
  # _pathname_transform_bruteforce (_FUNCTION_TRANSFORM)
  # _pathname_transform_cd_pwd (_FUNCTION_TRANSFORM)
  # _pathname_transform_realpath (_FUNCTION_TRANSFORM)
  # _pathname_validate
  # _pathnames_scan
  # _show_error
  # _show_help
  # _show_warning
# _parse_parameters
# _trap

#+ setup here +#

# variables:
# LC_ALL
# TZ
# _ARRAY_HOLDNAMES (single dimension indexed array)
# _ARRAY_PATHNAMES (single dimension indexed array)
# _FUNCTION_SUM (_pathname_md5sum_md5sum _pathname_openssl_md5sum _pathname_openssl_sha1sum _pathname_openssl_sha224sum _pathname_openssl_sha256sum _pathname_openssl_sha384sum _pathname_openssl_sha512sum _pathname_sha1sum_sha1sum _pathname_sha224sum_sha224sum _pathname_sha256sum_sha256sum _pathname_sha384sum_sha384sum _pathname_sha512sum_sha512sum)
# _FUNCTION_TRANSFORM (_pathname_transform_bruteforce _pathname_transform_cd_pwd _pathname_transform_realpath)
# _MY_GID
# _MY_UID
# _OPTIONS_CD (cd options, not script options)
# _OPTIONS_CP (cp options, not script options)
# _OPTIONS_LN (ln options, not script options)
# _OPTIONS_MV (mv options, not script options)
# _OPTIONS_PWD (pwd options, not script options)
# _OPTIONS_REALPATH (realpath options, not script options)
# _OPTIONS_READ (read options, not script options)
# _OPTIONS_READWRITE (find options. not script options)
# _OPTIONS_RM (rm options, not script options)
# _OPTIONS_UIDGID (find options. not script options)
# _OPTIONS_UNLINK (find options. not script options)
# _OPTIONS_XDEV (find options. not script options)

# - doing this here so we get no suprises in "function _binary_validate_setup",
#   "function _builtin_validate_setup", & "function _pathnames_scan"
unset _FUNCTION_SUM
unset _FUNCTION_TRANSFORM
unset _MY_GID
unset _MY_UID
unset _OPTIONS_CD
unset _OPTIONS_CP
unset _OPTIONS_LN
unset _OPTIONS_MV
unset _OPTIONS_PWD
unset _OPTIONS_READ
unset _OPTIONS_READWRITE
unset _OPTIONS_REALPATH
unset _OPTIONS_RM
unset _OPTIONS_UIDGID
unset _OPTIONS_UNLINK
unset _OPTIONS_XDEV

# - the locale specified by the environment affects sort order. set LC_ALL=C
#   to get the traditional sort order that uses native byte values
export LC_ALL=C

# - for timezone agnostic file timestamps in long/verbose listings as well as
#   (eventually) usage in the sqlite3 db
export TZ=UTC

# - be explicit for clarity
# - single dimension indexed array
declare -a _ARRAY_HOLDNAMES
declare -a _ARRAY_PATHNAMES

#- setup here -#

#+ function definitions here +#

# ORDER:
# - before calling _parse_parameters, but otherwise alphabetical

#+ marker trap live +#
# - except this one. 'tis special
function _trap()
{
  _eko_iod "#+ _trap +#"

  # functions:
  # _eko_iod
  # _eko_v

  # variables:
  # _BOOLEAN_DRYRUN
  # _BOOLEAN_UNLINK
  # _OPTIONS_RM (rm options, not script options)
  # _SD_MTIM_HMS (contrivance. not from stat(2))
  # _SD_MTIM_UTC (contrivance. not from stat(2))
  # _SD_MTIM_YMD (contrivance. not from stat(2))
  # _SD_NAME (contrivance. not from stat(2))
  # _ST_NAME (contrivance. not from stat(2))
  # _SU_NAME (contrivance. not from stat(2))

  # binaries:
  # rm
  # touch

  # NOTE:
  # - hardlinking & unlinking will require slightly different actions
  #   hardlinking: restore parent directory's timestamp
  #   unlinking: delete temp file. restore parent directory's timestamp
  # - for now, concentrate exclusively on cleaning up from unlinking

  # IDEA:
  # - set up a trap to catch what *can* be caught. the various $_S[DTU]_*
  #   variables will be pointed at the last directory/file processed along
  #   with the parent directory's timestamp, so cleaning up will be fairly
  #   straightforward
  # - also: _SU_NAME="${_ST_NAME}.scanfs.$_MY_UID:$_MY_GID.$PPID.$$"
  #   (already set in "function _pathnames_scan")

  # NOTE:
  # - regarding the parent directory's timestamp (specifically $_SD_MTIM_HMS),
  #   preserve nanoseconds & include them in the report so we know exactly
  #   what is & is not being preserved

  # IDEA:
  # - there's no kill like overkill. do a "bottom up" set of tests:
  # - ultimately, these can be done in any order. using a specific order makes
  #   maintenance easier
  # - this has a more logical feel to it. first & foremost, the temp file must
  #   exist. everything else depends on that
  #   $_SU_NAME exists & is a regular file
  #   $_SU_NAME matches $_ST_NAME with "[.].*$" via "=~" (anchor with "^")
  #   $_ST_NAME exists & is a regular file
  #   $_ST_NAME matches $_SD_NAME with "[/].*$" via "=~" (anchor with "^")
  #   $_SD_NAME exists & is a directory

  # above or below

  # IDEA:
  # - there's no kill like overkill. do a "top down" set of tests:
  # - ultimately, these can be done in any order. using a specific order makes
  #   maintenance easier
  #   $_SD_NAME exists & is a directory
  #   $_ST_NAME matches $_SD_NAME with "[/].*$" via "=~" (anchor with "^")
  #   $_ST_NAME exists & is a regular file
  #   $_SU_NAME matches $_ST_NAME with "[.].*$" via "=~" (anchor with "^")
  #   $_SU_NAME exists & is a regular file

  # - this test is known to work
  #if $_BOOLEAN_UNLINK \
  #&& [[ -d $_SD_NAME ]] \
  #&& [[ -f $_ST_NAME ]] \
  #&& [[ -f $_SU_NAME ]]

  # - use this ordering. if nothing else, it's aesthetically pleasing
  # - considerably more thorough than the above test
  #if $_BOOLEAN_UNLINK \
  #&& [[ -f $_SU_NAME ]] \
  #&& [[ $_SU_NAME =~ ^$_ST_NAME[.].*$ ]] \
  #&& [[ -f $_ST_NAME ]] \
  #&& [[ $_ST_NAME =~ ^$_SD_NAME[/].*$ ]] \
  #&& [[ -d $_SD_NAME ]]

  # - doublequote pathnames (but not the regex portions) for safety
  if $_BOOLEAN_UNLINK \
  && [[ -f "$_SU_NAME" ]] \
  && [[ "$_SU_NAME" =~ ^"$_ST_NAME"[.].*$ ]] \
  && [[ -f "$_ST_NAME" ]] \
  && [[ "$_ST_NAME" =~ ^"$_SD_NAME"[/].*$ ]] \
  && [[ -d "$_SD_NAME" ]]
  then
    _eko_v ""
    _eko_v "             \$_BOOLEAN_DRYRUN: \"$_BOOLEAN_DRYRUN\""
    _eko_v "             \$_BOOLEAN_UNLINK: \"$_BOOLEAN_UNLINK\""
    _eko_v "                    \$_SU_NAME: \"$_SU_NAME\""
    _eko_v "                    \$_ST_NAME: \"$_ST_NAME\""
    _eko_v "                    \$_SD_NAME: \"$_SD_NAME\""
    _eko_v "                    \$_SD_MTIM: \"$_SD_MTIM_YMD $_SD_MTIM_HMS $_SD_MTIM_UTC\""

    # - put the dry-run test here so we get the above report but
    #   (conditionally) prevent the below actions
    if ! $_BOOLEAN_DRYRUN
    then
      rm $_OPTIONS_RM -- "$_SU_NAME"

      # FIXME:
      # - not 100% certain, but I *think* the wrong timestamp is being used

      # - there is a single (known) special case where attempting to restore
      #   the parent directory's timestamp will fail. script run as non-root.
      #   unlinking files in a directory that is itself mode 1777 (drwxrwxrwt)
      #   & owned by someone other than oneself. hence the "2>/dev/null"
      #   below
      touch --date="$_SD_MTIM_YMD $_SD_MTIM_HMS $_SD_MTIM_UTC" "$_SD_NAME" 2>/dev/null
    fi
  fi

  _eko_iod "#- _trap -#"

  exit 1
}
#- marker trap live -#

#+ marker trap test +#
# - except this one. 'tis special
function _trap_test()
{
  _eko_iod "#+ _trap_test +#"

  # functions:
  # _eko_iod
  # _eko_v

  # variables:
  # _BOOLEAN_DRYRUN
  # _BOOLEAN_UNLINK
  # _OPTIONS_RM (rm options, not script options)
  # _SD_MTIM_HMS (contrivance. not from stat(2))
  # _SD_MTIM_UTC (contrivance. not from stat(2))
  # _SD_MTIM_YMD (contrivance. not from stat(2))
  # _SD_NAME (contrivance. not from stat(2))
  # _ST_NAME (contrivance. not from stat(2))
  # _SU_NAME (contrivance. not from stat(2))

  # binaries:
  # rm
  # touch

beeps

  # NOTE:
  # - hardlinking & unlinking will require slightly different actions
  #   hardlinking: restore parent directory's timestamp
  #   unlinking: delete temp file. restore parent directory's timestamp
  # - for now, concentrate exclusively on cleaning up from unlinking

  # IDEA:
  # - set up a trap to catch what *can* be caught. the various $_S[DTU]_*
  #   variables will be pointed at the last directory/file processed along
  #   with the parent directory's timestamp, so cleaning up will be fairly
  #   straightforward
  # - also: _SU_NAME="${_ST_NAME}.scanfs.$_MY_UID:$_MY_GID.$PPID.$$"
  #   (already set in "function _pathnames_scan")

  # NOTE:
  # - regarding the parent directory's timestamp (specifically $_SD_MTIM_HMS),
  #   preserve nanoseconds & include them in the report so we know exactly
  #   what is & is not being preserved

  # IDEA:
  # - there's no kill like overkill. do a "bottom up" set of tests:
  # - ultimately, these can be done in any order. using a specific order makes
  #   maintenance easier
  # - this has a more logical feel to it. first & foremost, the temp file must
  #   exist. everything else depends on that
  #   $_SU_NAME exists & is a regular file
  #   $_SU_NAME matches $_ST_NAME with "[.].*$" via "=~" (anchor with "^")
  #   $_ST_NAME exists & is a regular file
  #   $_ST_NAME matches $_SD_NAME with "[/].*$" via "=~" (anchor with "^")
  #   $_SD_NAME exists & is a directory

  # above or below

  # IDEA:
  # - there's no kill like overkill. do a "top down" set of tests:
  # - ultimately, these can be done in any order. using a specific order makes
  #   maintenance easier
  #   $_SD_NAME exists & is a directory
  #   $_ST_NAME matches $_SD_NAME with "[/].*$" via "=~" (anchor with "^")
  #   $_ST_NAME exists & is a regular file
  #   $_SU_NAME matches $_ST_NAME with "[.].*$" via "=~" (anchor with "^")
  #   $_SU_NAME exists & is a regular file

  # - this test is known to work
  #if $_BOOLEAN_UNLINK \
  #&& [[ -d $_SD_NAME ]] \
  #&& [[ -f $_ST_NAME ]] \
  #&& [[ -f $_SU_NAME ]]

  # - use this ordering. if nothing else, it's aesthetically pleasing
  # - considerably more thorough than the above test
  #if $_BOOLEAN_UNLINK \
  #&& [[ -f $_SU_NAME ]] \
  #&& [[ $_SU_NAME =~ ^$_ST_NAME[.].*$ ]] \
  #&& [[ -f $_ST_NAME ]] \
  #&& [[ $_ST_NAME =~ ^$_SD_NAME[/].*$ ]] \
  #&& [[ -d $_SD_NAME ]]

# IDEA:
# - I suspect the temp file is not being created
# - parent directory's timestamp is current time (even with "live" version)
# - added "press the any key to continue: " immediately preceding the "exit 1"
#   so I can inspect the filesystem at my leisure. huge fail
# - I don't need this shit. troubleshooting my troubleshooting. yeah, no

# IDEA: (different approach #1)
# - "#+ test dump +# / #- test dump -#" so I can see what's what
# - all requisite information is correct. why doesn't this work?

# IDEA: (different approach #2)
# - put various [[]] conditionals to see if the files even *exist* when this
#   routine is reached

# IDEA: (different approach #3)
# - just dump everything used in this function to stdout via _eko_v *outside*
#   any conditionals. let's get a view of anything/everything available

#+ marker trap test +#
  # - currently untested
  _eko_v "t: \$_BOOLEAN_DRYRUN: \"$_BOOLEAN_DRYRUN\""
  _eko_v "t: \$_BOOLEAN_UNLINK: \"$_BOOLEAN_UNLINK\""
  _eko_v "t: \$_OPTIONS_RM: \"$_OPTIONS_RM\""
  _eko_v "t: \$_SD_NAME: \"$_SD_NAME\""
  _eko_v "t: \$_ST_NAME: \"$_ST_NAME\""
  _eko_v "t: \$_SU_NAME: \"$_SU_NAME\""
  _eko_v "t: \$_SD_MTIM_YMD: \"$_SD_MTIM_YMD\""
  _eko_v "t: \$_SD_MTIM_HMS: \"$_SD_MTIM_HMS\""
  _eko_v "t: \$_SD_MTIM_UTC: \"$_SD_MTIM_UTC\""
#- marker trap test -#

# TODO:
# - test to see if the outer if/then/fi construct is even *entered* when needed
# - the inner if/then/fi construct appears to be entered. maybe
# - added pass/fail stuff to see what's what. currently untested

  # - doublequote pathnames (but not the regex portions) for safety
  if $_BOOLEAN_UNLINK \
  && [[ -f "$_SU_NAME" ]] \
  && [[ "$_SU_NAME" =~ ^"$_ST_NAME"[.].*$ ]] \
  && [[ -f "$_ST_NAME" ]] \
  && [[ "$_ST_NAME" =~ ^"$_SD_NAME"[/].*$ ]] \
  && [[ -d "$_SD_NAME" ]]
  then
#+ marker trap test +#
    _eko_v "t: outer: pass"
#- marker trap test -#
    _eko_v ""
    _eko_v "             \$_BOOLEAN_DRYRUN: \"$_BOOLEAN_DRYRUN\""
    _eko_v "             \$_BOOLEAN_UNLINK: \"$_BOOLEAN_UNLINK\""
    _eko_v "                    \$_SU_NAME: \"$_SU_NAME\""
    _eko_v "                    \$_ST_NAME: \"$_ST_NAME\""
    _eko_v "                    \$_SD_NAME: \"$_SD_NAME\""
    _eko_v "                    \$_SD_MTIM: \"$_SD_MTIM_YMD $_SD_MTIM_HMS $_SD_MTIM_UTC\""

    # - put the dry-run test here so we get the above report but
    #   (conditionally) prevent the below actions
    if ! $_BOOLEAN_DRYRUN
    then
#+ marker trap test +#
      _eko_v "t: inner: pass"
#- marker trap test -#

#+ testing +#
    _eko_v "#+ test dump +#"
    # - does this file exist? parent directory's timestamp is updated, so?
    # - NOTE: parent directory's timestamp restored if files are non-sparse
    # - TODO: test again with sparse files
    # - TODO: verify that this file does, in fact, exist
    _eko_v "                    \$_SU_NAME: \"$_SU_NAME\""
#- testing -#

      # - this succeeds (I think. see above)
#echo \
      rm $_OPTIONS_RM -- "$_SU_NAME"

      # FIXME:
      # - not 100% certain, but I *think* the wrong timestamp is being used
      # ^ it's the current time. why?

      # - there is a single (known) special case where attempting to restore
      #   the parent directory's timestamp will fail. script run as non-root.
      #   unlinking files in a directory that is itself mode 1777 (drwxrwxrwt)
      #   & owned by someone other than oneself. hence the "2>/dev/null"
      #   below

#+ testing +#
    # - all 3 are correct
    _eko_v "                \$_SD_MTIM_YMD: \"$_SD_MTIM_YMD\""
    _eko_v "                \$_SD_MTIM_HMS: \"$_SD_MTIM_HMS\""
    _eko_v "                \$_SD_MTIM_UTC: \"$_SD_MTIM_UTC\""

    # - so is this
    _eko_v "                    \$_SD_NAME: \"$_SD_NAME\""
    _eko_v "#- test dump -#"
#- testing -#

# NOTE:
# - test data is a set of 1073741824 byte files hardlinked together
# - for some bizarre reason, the directory's timestamp is not updated with the
#   below "touch" if the test files are completely sparse. if the test files
#   are forcibly created non-sparse & the script is run against *that* set,
#   everything works properly

      # - this fails
      # - but apparently only with large sparse files. what?
#echo \
      touch --date="$_SD_MTIM_YMD $_SD_MTIM_HMS $_SD_MTIM_UTC" "$_SD_NAME"
# 2>/dev/null
#+ marker trap test +#
    else
      _eko_v "t: inner: fail"
#- marker trap test -#
    fi
#+ marker trap test +#
  else
    _eko_v "t: outer: fail"
#- marker trap test -#
  fi

# - nope. I assume it's catching the ^C
#read -p "press the any key to continue: " -n 1 _CHAR
# - still nope. wtf?
#read -p "press the any key to continue: " -n 2 _CHAR
# - fine. this doesn't even work. time to use brute force
#read -p "press the any key to continue: " _CHAR
# - oh, ffs. THIS doesn't work?
#read -p "press the any key to continue: " -t 86400

# - random test
# - it DOES reach this point
#beeps

  _eko_iod "#- _trap_test -#"

  exit 1
}
#- marker trap test -#

# - refer to bash(1) section "SHELL BUILTIN COMMANDS" & signal(7) section
#   "Standard signals" for additional details
#trap _trap SIGINT SIGTERM
trap _trap_test SIGINT SIGTERM
#trap#

function _binary_validate_setup()
{
  _eko_iod "#+ _binary_validate_setup +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v
  # _pathname_md5sum_md5sum (_FUNCTION_SUM)
  # _pathname_openssl_md5sum (_FUNCTION_SUM)
  # _pathname_openssl_sha1sum (_FUNCTION_SUM)
  # _pathname_openssl_sha224sum (_FUNCTION_SUM)
  # _pathname_openssl_sha256sum (_FUNCTION_SUM)
  # _pathname_openssl_sha384sum (_FUNCTION_SUM)
  # _pathname_openssl_sha512sum (_FUNCTION_SUM)
  # _pathname_sha1sum_sha1sum (_FUNCTION_SUM)
  # _pathname_sha224sum_sha224sum (_FUNCTION_SUM)
  # _pathname_sha256sum_sha256sum (_FUNCTION_SUM)
  # _pathname_sha384sum_sha384sum (_FUNCTION_SUM)
  # _pathname_sha512sum_sha512sum (_FUNCTION_SUM)
  # _pathname_transform_bruteforce (_FUNCTION_TRANSFORM)
  # _pathname_transform_realpath (_FUNCTION_TRANSFORM)
  # _show_error

  # variables:
  # _BINARY_HELP
  # _BINARY_NAME
  # _BINARY_OPTION
  # _BOOLEAN_HARDLINK
  # _BOOLEAN_MD5SUM
  # _BOOLEAN_NONSPARSE
  # _BOOLEAN_SHA1SUM
  # _BOOLEAN_SHA224SUM
  # _BOOLEAN_SHA256SUM
  # _BOOLEAN_SHA384SUM
  # _BOOLEAN_SHA512SUM
  # _BOOLEAN_SPARSE
  # _BOOLEAN_UNLINK
  # _BOOLEAN_XDEV
  # _FUNCTION_SUM (_pathname_md5sum_md5sum _pathname_openssl_md5sum _pathname_openssl_sha1sum _pathname_openssl_sha224sum _pathname_openssl_sha256sum _pathname_openssl_sha384sum _pathname_openssl_sha512sum _pathname_sha1sum_sha1sum _pathname_sha224sum_sha224sum _pathname_sha256sum_sha256sum _pathname_sha384sum_sha384sum _pathname_sha512sum_sha512sum)
  # _FUNCTION_TRANSFORM (_pathname_transform_bruteforce _pathname_transform_cd_pwd _pathname_transform_realpath)
  # _MY_GID
  # _MY_UID
  # _OPTIONS_CP (cp options, not script options)
  # _OPTIONS_LN (ln options, not script options)
  # _OPTIONS_MV (mv options, not script options)
  # _OPTIONS_RM (rm options, not script options)
  # _OPTIONS_REALPATH (realpath options, not script options)
  # _OPTION_SUM_SIZE

  # binaries:
  # basename (fallback with dirname/find to realpath)
  # cp
  # dirname (fallback with basename/find to realpath)
  # find
  # head
  # id
  # ln
  # md5sum
  # mv
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)
  # realpath
  # rm
  # sha1sum
  # sha224sum
  # sha256sum
  # sha384sum
  # sha512sum
  # sort
  # touch

  # NOTE:
  # - rather than test a given binary's version in hopes of figuring out which
  #   features it supports, test its supported feature set directly. not only
  #   is this much simpler to do, it's possible to test only those features
  #   that are explicitly used in the script
  # - how? get the binary to dump its embedded help text & parse the result
  # - this can be used as a dual test. no help text = no binary, otherwise
  #   parse the help text for descriptions of specific features

  # NOTE:
  # - be explicit, use long form options when available

  # NOTE:
  # - the logic of the md5sum<>openssl vs realpath<>basename/dirname/find
  #   tests differ subtly but significantly, but the end result is the same

  # NOTE:
  # - ordering: by standalone binary or by the first named in ranked binary
  #   sequences (pairs, triplets, or endlessly more)
  # - each set is explicitly wrapped in $_BOOLEAN_* tests as appropriate. it's
  #   much easier to maintain & at the same time *still* test only those
  #   binaries & options used for specific actions

  # NOTE:
  # - several, but not all, _OPTIONS_* are set up here, others in
  #   "function _pathnames_scan"

  # - be explicit for clarity. we'll be testing this variable further below
  unset _FUNCTION_SUM

  if $_BOOLEAN_UNLINK
  then
    #+ cp +#
    # - "cp --help". stdout
    #   "-f" (use "--force")
    #   "-P" (use "--no-dereference")
    #   "-p" (use "--preserve=all". "=" required)
    #   "--sparse=always" ("=" required)
    #   "--sparse=never" ("=" required)
    # - called in "function _pathnames_scan"
    # - $_BOOLEAN_NONSPARSE is true/false
    # - $_BOOLEAN_SPARSE is true/false
    # - $_BOOLEAN_UNLINK is true
    # - _OPTIONS_CP is set

    _BINARY_NAME=cp
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--force
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_CP=$_BINARY_OPTION
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi

      _BINARY_OPTION=--no-dereference
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_CP+=" "$_BINARY_OPTION
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi

      _BINARY_OPTION=--preserve=all
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_CP+=" "$_BINARY_OPTION
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi

      if $_BOOLEAN_SPARSE
      then
        _BINARY_OPTION=--sparse=always
        if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
        then
          _OPTIONS_CP+=" "$_BINARY_OPTION
        else
          _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
        fi
      fi # $_BOOLEAN_SPARSE

      if $_BOOLEAN_NONSPARSE
      then
        _BINARY_OPTION=--sparse=never
        if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
        then
          _OPTIONS_CP+=" "$_BINARY_OPTION
        else
          _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
        fi
      fi # $_BOOLEAN_NONSPARSE
#      _eko_v "                 \$_OPTIONS_CP: \"$_OPTIONS_CP\""
      _eko_pv "\$_OPTIONS_CP:" \""$_OPTIONS_CP\""
    fi
    #- cp -#
  fi # $_BOOLEAN_UNLINK

  #+ find +#
  # - "find --help". stdout
  #   "-gid"
  #   "-links"
  #   "-maxdepth"
  #   "-printf"
  #   "-readable"
  #   "-type"
  #   "-uid"
  #   "-writable"
  #   "-xdev"
  # - called in "function _pathname_transform_bruteforce"
  # - called in "function _pathname_validate"
  # - called in "function _pathnames_scan"
  # - $_BOOLEAN_HARDLINK is true/false (TODO. unimplemented)
  # - $_BOOLEAN_UNLINK is true/false
  # - $_BOOLEAN_XDEV is true/false

  _BINARY_NAME=find
  _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
  if [[ $_BINARY_HELP =~ "command not found" ]]
  then
    _show_error "required binary \"$_BINARY_NAME\" not found"
  else
    if $_BOOLEAN_HARDLINK \
    || $_BOOLEAN_UNLINK
    then
      _BINARY_OPTION=-gid
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi # $_BOOLEAN_HARDLINK $_BOOLEAN_UNLINK

    if $_BOOLEAN_UNLINK
    then
      _BINARY_OPTION=-links
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi # $_BOOLEAN_UNLINK

    _BINARY_OPTION=-maxdepth
    if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
    then
      _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
    fi

    _BINARY_OPTION=-printf
    if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
    then
      _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
    fi

    _BINARY_OPTION=-readable
    if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
    then
      _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
    fi

    _BINARY_OPTION=-type
    if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
    then
      _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
    fi

    if $_BOOLEAN_HARDLINK \
    || $_BOOLEAN_UNLINK
    then
      _BINARY_OPTION=-uid
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi # $_BOOLEAN_HARDLINK $_BOOLEAN_UNLINK

    if $_BOOLEAN_HARDLINK \
    || $_BOOLEAN_UNLINK
    then
      _BINARY_OPTION=-writable
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi # $_BOOLEAN_HARDLINK $_BOOLEAN_UNLINK

    if $_BOOLEAN_XDEV
    then
      _BINARY_OPTION=-xdev
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi # $_BOOLEAN_XDEV
  fi
  #- find -#

  # - "-n string" = true if the length of string is non-zero
  if $_BOOLEAN_MD5SUM \
  && [[ -n $_OPTION_SUM_SIZE ]]
  then
    #+ head +#
    # - "head --help". stdout
    #   "-c" (use "--bytes") ("=" is optional, use "=" for uniformity)
    # - called in "function _pathname_md5sum_md5sum"
    # - called in "function _pathname_openssl_md5sum"
    # - called in "function _pathname_openssl_sha1sum"
    # - called in "function _pathname_openssl_sha224sum"
    # - called in "function _pathname_openssl_sha256sum"
    # - called in "function _pathname_openssl_sha384sum"
    # - called in "function _pathname_openssl_sha512sum"
    # - called in "function _pathname_sha1sum_sha1sum"
    # - called in "function _pathname_sha224sum_sha224sum"
    # - called in "function _pathname_sha256sum_sha256sum"
    # - called in "function _pathname_sha384sum_sha384sum"
    # - called in "function _pathname_sha512sum_sha512sum"
    # - $_BOOLEAN_MD5SUM is true
    # - $_OPTION_SUM_SIZE is non-zero length

    _BINARY_NAME=head
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    _BINARY_HELP=${_BINARY_HELP//=/ }
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--bytes
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- head -#
  fi # $_BOOLEAN_MD5SUM $_OPTION_SUM_SIZE

  if $_BOOLEAN_HARDLINK \
  || $_BOOLEAN_UNLINK
  then
    #+ id +#
    # - "id --help". stdout
    #   "-g" (use "--group")
    #   "-u" (use "--user")
    # - called in "function _binary_validate_setup" (this function)
    # - $_BOOLEAN_HARDLINK is true/false (TODO. unimplemented)
    # - $_BOOLEAN_UNLINK is true/false
    # - _MY_GID is set
    # - _MY_UID is set

    _BINARY_NAME=id
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--group
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        # - no doublequotes on the binary or its option. aka: NO CAPES!
        _MY_GID=$($_BINARY_NAME $_BINARY_OPTION)
#        _eko_v "                     \$_MY_GID: \"$_MY_GID\""
        _eko_pv "\$_MY_GID:" \""$_MY_GID\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi

      _BINARY_OPTION=--user
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        # - no doublequotes on the binary or its option. aka: NO CAPES!
        _MY_UID=$($_BINARY_NAME $_BINARY_OPTION)
#        _eko_v "                     \$_MY_UID: \"$_MY_UID\""
        _eko_pv "\$_MY_UID:" \""$_MY_UID\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- id -#
  fi # $_BOOLEAN_HARDLINK $_BOOLEAN_UNLINK

  if $_BOOLEAN_HARDLINK
  then
    #+ ln +#
    # - "ln --help". stdout
    #   "-f" (use "--force")
    # - called in "function _pathnames_scan"
    # - $_BOOLEAN_HARDLINK is true (TODO. unimplemented)
    # - _OPTIONS_LN is set

    _BINARY_NAME=ln
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--force
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_LN=$_BINARY_OPTION
#        _eko_v "                 \$_OPTIONS_LN: \"$_OPTIONS_LN\""
        _eko_pv "\$_OPTIONS_LN:" \""$_OPTIONS_LN\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- ln -#
  fi # $_BOOLEAN_HARDLINK

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_MD5SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    #+ md5sum +#
    # - "md5sum --help". stdout
    # - called in "function _pathname_md5sum_md5sum"
    # - $_BOOLEAN_MD5SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_md5sum_md5sum (1/2)

    _BINARY_NAME=md5sum
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _FUNCTION_SUM=_pathname_md5sum_md5sum
#      _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
      _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
    fi
    #- md5sum -#
  fi # $_BOOLEAN_MD5SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_MD5SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    # NOTE:
    # - it's highly unlikely, but the possibility does exist that the "md5sum"
    #   binary may not be available. if it's not, attempt to use the "openssl"
    #   binary in its place. openssl is ~13x larger & ~1/2 the speed of
    #   "md5sum", but slow is better than an avoidable error
    # - (special thanks to vbatts for the idea of using openssl as a fallback)

#+ marker binary size/speed +#

#  42668 md5sum
# 572208 openssl

# $ echo 572208 / 42668 | bc -l
# 13.41070591544014249554

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -m >/dev/null ; done
# real	0m28.143s
# user	0m9.674s
# sys	0m4.264s

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -m >/dev/null ; done
# real	1m1.692s
# user	0m40.779s
# sys	0m9.345s

# $ echo "( ( 0*60+28.143 ) / ( 1*60+1.692 ) )" | bc -l
# .45618556701030927835

#- marker binary size/speed -#

    #+ openssl (fallback to md5sum) +#
    # - naturally, there has to be ONE troublemaker. meh
    # - "openssl --help". stderr. anything not a valid option spits out help
    #   text. technically speaking, none of "--help", "-help", "-h", "-?" are
    #   supported. they all provide useful help text, though *shrug*
    # - "openssl --help 2>&1". stdout
    #   "dgst -md5" (no "-" on dgst [required]. "-" on md5 [required])
    # - beat the silly thing into submission:
    #   "openssl dgst -help 2>&1"
    # - called in "function _pathname_openssl_md5sum"
    # - $_BOOLEAN_MD5SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_openssl_md5sum (2/2)

    _BINARY_NAME=openssl
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binaries \"md5sum\" or \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=-md5
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _FUNCTION_SUM=_pathname_openssl_md5sum
#        _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
        _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- openssl (fallback to md5sum) -#
  fi # $_BOOLEAN_MD5SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA1SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    #+ sha1sum +#
    # - "sha1sum --help". stdout
    # - called in "function _pathname_sha1sum_sha1sum"
    # - $_BOOLEAN_SHA1SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_sha1sum_sha1sum (1/2)

    _BINARY_NAME=sha1sum
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _FUNCTION_SUM=_pathname_sha1sum_sha1sum
#      _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
      _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
    fi
    #- sha1sum -#
  fi # $_BOOLEAN_SHA1SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA1SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    # NOTE:
    # - it's highly unlikely, but the possibility does exist that the
    #   "sha1sum" binary may not be available. if it's not, attempt to use the
    #   "openssl" binary in its place. openssl is ~13x larger & ~1/2 the speed
    #   of "sha1sum", but slow is better than an avoidable error
    # - (special thanks to vbatts for the idea of using openssl as a fallback)

#+ marker binary size/speed +#

#  42668 sha1sum
# 572208 openssl

# $ echo 572208 / 42668 | bc -l
# 13.41070591544014249554

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -1 >/dev/null ; done
# real	0m31.624s
# user	0m13.314s
# sys	0m4.519s

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -1 >/dev/null ; done
# real	1m3.875s
# user	0m43.042s
# sys	0m9.190s

# $ echo "( ( 0*60+31.624 ) / ( 1*60+3.875 ) )" | bc -l
# .49509197651663405088

#- marker binary size/speed -#

    #+ openssl (fallback to sha1sum) +#
    # - naturally, there has to be ONE troublemaker. meh
    # - "openssl --help". stderr. anything not a valid option spits out help
    #   text. technically speaking, none of "--help", "-help", "-h", "-?" are
    #   supported. they all provide useful help text, though *shrug*
    # - "openssl --help 2>&1". stdout
    #   "dgst -sha1" (no "-" on dgst [required]. "-" on sha1 [required])
    # - beat the silly thing into submission:
    #   "openssl dgst -help 2>&1"
    # - called in "function _pathname_openssl_sha1sum"
    # - $_BOOLEAN_SHA1SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_openssl_sha1sum (2/2)

    _BINARY_NAME=openssl
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binaries \"sha1sum\" or \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=-sha1
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _FUNCTION_SUM=_pathname_openssl_sha1sum
#        _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
        _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- openssl (fallback to sha1sum) -#
  fi # $_BOOLEAN_SHA1SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA224SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    #+ sha224sum +#
    # - "sha224sum --help". stdout
    # - called in "function _pathname_sha224sum_sha224sum"
    # - $_BOOLEAN_SHA224SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_sha224sum_sha224sum (1/2)

    _BINARY_NAME=sha224sum
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _FUNCTION_SUM=_pathname_sha224sum_sha224sum
#      _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
      _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
    fi
    #- sha224sum -#
  fi # $_BOOLEAN_SHA224SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA224SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    # NOTE:
    # - it's highly unlikely, but the possibility does exist that the
    #   "sha224sum" binary may not be available. if it's not, attempt to use
    #   the "openssl" binary in its place. openssl is ~11x larger & ~1/2 the
    #   speed of "sha224sum", but slow is better than an avoidable error
    # - (special thanks to vbatts for the idea of using openssl as a fallback)

#+ marker binary size/speed +#

#  50860 sha224sum
# 572208 openssl

# $ echo 572208 / 50860 | bc -l
# 11.25064883995281163979

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -224 >/dev/null ; done
# real	0m41.724s
# user	0m23.357s
# sys	0m5.231s

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -224 >/dev/null ; done
# real	1m13.436s
# user	0m52.723s
# sys	0m9.082s

# $ echo "( ( 0*60+41.724 ) / ( 1*60+13.436 ) )" | bc -l
# .56816820088240100223

#- marker binary size/speed -#

    #+ openssl (fallback to sha224sum) +#
    # - naturally, there has to be ONE troublemaker. meh
    # - "openssl --help". stderr. anything not a valid option spits out help
    #   text. technically speaking, none of "--help", "-help", "-h", "-?" are
    #   supported. they all provide useful help text, though *shrug*
    # - "openssl --help 2>&1". stdout
    #   "dgst -sha224" (no "-" on dgst [required]. "-" on sha224 [required])
    # - beat the silly thing into submission:
    #   "openssl dgst -help 2>&1"
    # - called in "function _pathname_openssl_sha224sum"
    # - $_BOOLEAN_SHA224SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_openssl_sha224sum (2/2)

    _BINARY_NAME=openssl
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binaries \"sha224sum\" or \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=-sha224
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _FUNCTION_SUM=_pathname_openssl_sha224sum
#        _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
        _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- openssl (fallback to sha224sum) -#
  fi # $_BOOLEAN_SHA224SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA256SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    #+ sha256sum +#
    # - "sha256sum --help". stdout
    # - called in "function _pathname_sha256sum_sha256sum"
    # - $_BOOLEAN_SHA256SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_sha256sum_sha256sum (1/2)

    _BINARY_NAME=sha256sum
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _FUNCTION_SUM=_pathname_sha256sum_sha256sum
#      _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
      _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
    fi
    #- sha256sum -#
  fi # $_BOOLEAN_SHA256SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA256SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    # NOTE:
    # - it's highly unlikely, but the possibility does exist that the
    #   "sha256sum" binary may not be available. if it's not, attempt to use
    #   the "openssl" binary in its place. openssl is ~11x larger & ~1/2 the
    #   speed of "sha256sum", but slow is better than an avoidable error
    # - (special thanks to vbatts for the idea of using openssl as a fallback)

#+ marker binary size/speed +#

#  50860 sha256sum
# 572208 openssl

# $ echo 572208 / 50860 | bc -l
# 11.25064883995281163979

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -256 >/dev/null ; done
# real	0m41.805s
# user	0m23.580s
# sys	0m5.078s

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -256 >/dev/null ; done
# real	1m13.567s
# user	0m52.638s
# sys	0m9.216s

# $ echo "( ( 0*60+41.805 ) / ( 1*60+13.567 ) )" | bc -l
# .56825750676254298802

#- marker binary size/speed -#

    #+ openssl (fallback to sha256sum) +#
    # - naturally, there has to be ONE troublemaker. meh
    # - "openssl --help". stderr. anything not a valid option spits out help
    #   text. technically speaking, none of "--help", "-help", "-h", "-?" are
    #   supported. they all provide useful help text, though *shrug*
    # - "openssl --help 2>&1". stdout
    #   "dgst -sha256" (no "-" on dgst [required]. "-" on sha256 [required])
    # - beat the silly thing into submission:
    #   "openssl dgst -help 2>&1"
    # - called in "function _pathname_openssl_sha256sum"
    # - $_BOOLEAN_SHA256SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_openssl_sha256sum (2/2)

    _BINARY_NAME=openssl
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binaries \"sha256sum\" or \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=-sha256
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _FUNCTION_SUM=_pathname_openssl_sha256sum
#        _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
        _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- openssl (fallback to sha256sum) -#
  fi # $_BOOLEAN_SHA256SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA384SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    #+ sha384sum +#
    # - "sha384sum --help". stdout
    # - called in "function _pathname_sha384sum_sha384sum"
    # - $_BOOLEAN_SHA384SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_sha384sum_sha384sum (1/2)

    _BINARY_NAME=sha384sum
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _FUNCTION_SUM=_pathname_sha384sum_sha384sum
#      _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
      _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
    fi
    #- sha384sum -#
  fi # $_BOOLEAN_SHA384SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA384SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    # NOTE:
    # - it's highly unlikely, but the possibility does exist that the
    #   "sha384sum" binary may not be available. if it's not, attempt to use
    #   the "openssl" binary in its place. openssl is ~6x larger & ~3/4 the
    #   speed of "sha384sum", but slow is better than an avoidable error
    # - (special thanks to vbatts for the idea of using openssl as a fallback)

#+ marker binary size/speed +#

#  91820 sha384sum
# 572208 openssl

# $ echo 572208 / 91820 | bc -l
# 6.23184491396209976040

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -384 >/dev/null ; done
# real	1m6.671s
# user	0m48.863s
# sys	0m5.922s

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -384 >/dev/null ; done
# real	1m28.774s
# user	1m7.787s
# sys	0m9.280s

# $ echo "( ( 1*60+6.671 ) / ( 1*60+28.774 ) )" | bc -l
# .75101944262959875639

#- marker binary size/speed -#

    #+ openssl (fallback to sha384sum) +#
    # - naturally, there has to be ONE troublemaker. meh
    # - "openssl --help". stderr. anything not a valid option spits out help
    #   text. technically speaking, none of "--help", "-help", "-h", "-?" are
    #   supported. they all provide useful help text, though *shrug*
    # - "openssl --help 2>&1". stdout
    #   "dgst -sha384" (no "-" on dgst [required]. "-" on sha256 [required])
    # - beat the silly thing into submission:
    #   "openssl dgst -help 2>&1"
    # - called in "function _pathname_openssl_sha384sum"
    # - $_BOOLEAN_SHA384SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_openssl_sha384sum (2/2)

    _BINARY_NAME=openssl
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binaries \"sha384sum\" or \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=-sha384
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _FUNCTION_SUM=_pathname_openssl_sha384sum
#        _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
        _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- openssl (fallback to sha384sum) -#
  fi # $_BOOLEAN_SHA384SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA512SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    #+ sha512sum +#
    # - "sha512sum --help". stdout
    # - called in "function _pathname_sha512sum_sha512sum"
    # - $_BOOLEAN_SHA512SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_sha512sum_sha512sum (1/2)

    _BINARY_NAME=sha512sum
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _FUNCTION_SUM=_pathname_sha512sum_sha512sum
#      _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
      _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
    fi
    #- sha512sum -#
  fi # $_BOOLEAN_SHA512SUM $_FUNCTION_SUM

  # - "-z string" = true if the length of string is zero
  if $_BOOLEAN_SHA512SUM \
  && [[ -z $_FUNCTION_SUM ]]
  then
    # NOTE:
    # - it's highly unlikely, but the possibility does exist that the
    #   "sha512sum" binary may not be available. if it's not, attempt to use
    #   the "openssl" binary in its place. openssl is ~6x larger & ~3/4 the
    #   speed of "sha512sum", but slow is better than an avoidable error
    # - (special thanks to vbatts for the idea of using openssl as a fallback)

#+ marker binary size/speed +#

#  91820 sha512sum
# 572208 openssl

# $ echo 572208 / 91820 | bc -l
# 6.23184491396209976040

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -512 >/dev/null ; done
# real	1m6.868s
# user	0m48.880s
# sys	0m5.935s

# $ time for i in 1 2 3 ; do scanfs -p /usr/bin/ -512 >/dev/null ; done
# real	1m28.911s
# user	1m8.187s
# sys	0m9.087s

# $ echo "( ( 1*60+6.868 ) / ( 1*60+28.911 ) )" | bc -l
# .75207792061724645994

#- marker binary size/speed -#

    #+ openssl (fallback to sha512sum) +#
    # - naturally, there has to be ONE troublemaker. meh
    # - "openssl --help". stderr. anything not a valid option spits out help
    #   text. technically speaking, none of "--help", "-help", "-h", "-?" are
    #   supported. they all provide useful help text, though *shrug*
    # - "openssl --help 2>&1". stdout
    #   "dgst -sha512" (no "-" on dgst [required]. "-" on sha256 [required])
    # - beat the silly thing into submission:
    #   "openssl dgst -help 2>&1"
    # - called in "function _pathname_openssl_sha512sum"
    # - $_BOOLEAN_SHA512SUM is true
    # - $_FUNCTION_SUM is empty/unset
    # - _FUNCTION_SUM is set to _pathname_openssl_sha512sum (2/2)

    _BINARY_NAME=openssl
#disabled#
    _BINARY_HELP=$(echo $($_BINARY_NAME dgst --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binaries \"sha512sum\" or \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=-sha512
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _FUNCTION_SUM=_pathname_openssl_sha512sum
#        _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
        _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- openssl (fallback to sha512sum) -#
  fi # $_BOOLEAN_SHA512SUM $_FUNCTION_SUM

  if $_BOOLEAN_UNLINK
  then
    #+ mv +#
    # - "mv --help". stdout
    #   "-f" (use "--force")
    # - called in "function _pathnames_scan"
    # - $_BOOLEAN_UNLINK is true
    # - _OPTIONS_MV is set

    _BINARY_NAME=mv
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--force
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_MV=$_BINARY_OPTION
#        _eko_v "                 \$_OPTIONS_MV: \"$_OPTIONS_MV\""
        _eko_pv "\$_OPTIONS_MV:" \""$_OPTIONS_MV\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- mv -#
  fi # $_BOOLEAN_UNLINK

  # - "-z string" = true if the length of string is zero
  if [[ -z $_FUNCTION_TRANSFORM ]]
  then
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_cd_pwd (1/3)
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_realpath (2/3)
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_bruteforce (3/3)

    #+ realpath +#
    # - "realpath --help". stdout
    #   "-e" (use "--canonicalize-existing")
    #   "-P" (use "--physical")
    # - called in "function _pathname_transform_realpath"
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_realpath (2/3)
    # - _OPTIONS_REALPATH is set

    _BINARY_NAME=realpath
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ ! $_BINARY_HELP =~ "command not found" ]]
    then
      _BINARY_OPTION=--canonicalize-existing
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_REALPATH=$_BINARY_OPTION
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi

      _BINARY_OPTION=--physical
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_REALPATH+=" "$_BINARY_OPTION
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi

      # - it's much more graceful, but may not be available. if the tests
      #   reach this far, then it does exist & it does support the required
      #   options
      _FUNCTION_TRANSFORM=_pathname_transform_realpath
#      _eko_v "           \$_OPTIONS_REALPATH: \"$_OPTIONS_REALPATH\""
#      _eko_v "         \$_FUNCTION_TRANSFORM: \"$_FUNCTION_TRANSFORM\""
      _eko_pv "\$_OPTIONS_REALPATH:" \""$_OPTIONS_REALPATH\""
      _eko_pv "\$_FUNCTION_TRANSFORM:" \""$_FUNCTION_TRANSFORM\""
    fi
    #- realpath -#
  fi

  # - "-z string" = true if the length of string is zero
  if [[ -z $_FUNCTION_TRANSFORM ]]
  then
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_cd_pwd (1/3)
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_realpath (2/3)
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_bruteforce (3/3)

    #+ basename (fallback with dirname/find to realpath) +#
    # - "basename --help". stdout
    # - called in "function _pathname_transform_bruteforce"
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_bruteforce (3/3)

    _BINARY_NAME=basename
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    fi
    #- basename (fallback with dirname/find to realpath) -#

    #+ dirname (fallback with basename/find to realpath) +#
    # - "dirname --help". stdout
    # - called in "function _pathname_transform_bruteforce"
    # - _FUNCTION_TRANSFORM is set to _pathname_transform_bruteforce (3/3)

    _BINARY_NAME=dirname
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    fi
    #- dirname (fallback with basename/find to realpath) -#

    # - it's ugly, but it definitely works
    _FUNCTION_TRANSFORM=_pathname_transform_bruteforce
#    _eko_v "         \$_FUNCTION_TRANSFORM: \"$_FUNCTION_TRANSFORM\""
    _eko_pv "\$_FUNCTION_TRANSFORM:" \""$_FUNCTION_TRANSFORM\""
  fi

  if $_BOOLEAN_HARDLINK \
  || $_BOOLEAN_UNLINK
  then
    #+ rm +#
    # - "rm --help". stdout
    #   "-f" (use "--force")
    # - called in "function _trap"
    # - $_BOOLEAN_HARDLINK is true/false (TODO. unimplemented)
    # - $_BOOLEAN_UNLINK is true/false
    # - _OPTIONS_RM is set

    _BINARY_NAME=rm
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--force
      if [[ " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _OPTIONS_RM=$_BINARY_OPTION
#        _eko_v "                 \$_OPTIONS_RM: \"$_OPTIONS_RM\""
        _eko_pv "\$_OPTIONS_RM:" \""$_OPTIONS_RM\""
      else
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- rm -#
  fi # $_BOOLEAN_HARDLINK $_BOOLEAN_UNLINK

  #+ sort +#
  # - "sort --help". stdout
  #   "-k" (use "--key") ("=" is optional, use "=" for uniformity)
  # - called in "function _pathnames_scan"

  _BINARY_NAME=sort
  _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
  _BINARY_HELP=${_BINARY_HELP//=/ }
  if [[ $_BINARY_HELP =~ "command not found" ]]
  then
    _show_error "required binary \"$_BINARY_NAME\" not found"
  else
    _BINARY_OPTION=--key
    if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
    then
      _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
    fi
  fi
  #- sort -#

  if $_BOOLEAN_HARDLINK \
  || $_BOOLEAN_UNLINK
  then
    #+ touch +#
    # - "touch --help". stdout
    #   "-d" (use "--date") ("=" is optional, use "=" for uniformity)
    # - called in "function _pathnames_scan"
    # - $_BOOLEAN_HARDLINK is true/false (TODO. unimplemented)
    # - $_BOOLEAN_UNLINK is true/false
    # - $_BOOLEAN_TIMESTAMP is true/false (set in "function _pathnames_scan")
    # - $_SD_MTIM_HMS is referenced in "function _trap"
    # - $_SD_MTIM_UTC is referenced in "function _trap"
    # - $_SD_MTIM_YMD is referenced in "function _trap"
    # - $_SD_NAME is referenced in "function _trap"

    _BINARY_NAME=touch
    _BINARY_HELP=$(echo $($_BINARY_NAME --help 2>&1))
    _BINARY_HELP=${_BINARY_HELP//=/ }
    if [[ $_BINARY_HELP =~ "command not found" ]]
    then
      _show_error "required binary \"$_BINARY_NAME\" not found"
    else
      _BINARY_OPTION=--date
      if [[ ! " $_BINARY_HELP " =~ " $_BINARY_OPTION " ]]
      then
        _show_error \""$_BINARY_NAME\" does not support \"$_BINARY_OPTION\""
      fi
    fi
    #- touch -#
  fi # $_BOOLEAN_HARDLINK $_BOOLEAN_UNLINK

  _eko_iod "#- _binary_validate_setup -#"
}

function _builtin_validate_setup()
{
  _eko_iod "#+ _builtin_validate_setup +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v
  # _pathname_transform_cd_pwd (_FUNCTION_TRANSFORM)
  # _show_error

  # variables:
  # _BUILTIN_HELP
  # _BUILTIN_NAME
  # _BUILTIN_OPTION
  # _FUNCTION_TRANSFORM (_pathname_transform_bruteforce _pathname_transform_cd_pwd _pathname_transform_realpath)
  # _OPTIONS_CD (cd options, not script options)
  # _OPTIONS_PWD (pwd options, not script options)
  # _OPTIONS_READ (read options, not script options)

  # builtins:
  # cd (in combination with pwd, fallback to basename/dirname/find/realpath)
  # pwd (in combination with cd, fallback to basename/dirname/find/realpath)
  # read

  # NOTE:
  # - rather than test a given builtin's version (or more accurately, test a
  #   given version of bash itself) in hopes of figuring out which features it
  #   supports, test its supported feature set directly. not only is this much
  #   simpler to do, it's possible to test only those features that are
  #   explicitly used in the script
  # - how? get the builtin to dump its embedded help text & parse the result
  # - this can be used as a dual test. no help text = unsupported builtin,
  #   otherwise parse the help text for descriptions of specific features

  # NOTE:
  # - technically speaking, we only need 1 of the following 2 tests to succeed

  # - be explicit for clarity. we'll be testing this variable in
  #   "function _binary_validate_setup"
  unset _FUNCTION_TRANSFORM

  # - _FUNCTION_TRANSFORM is set to _pathname_transform_cd_pwd (1/3)
  # - _FUNCTION_TRANSFORM is set to _pathname_transform_realpath (2/3)
  # - _FUNCTION_TRANSFORM is set to _pathname_transform_bruteforce (3/3)

  # - be explicit for clarity. we'll be testing this variable further below
  unset _OPTIONS_CD

  #+ cd +#
  # - "help cd". stdout
  #   "-P"
  # - called in "function _pathname_transform_cd_pwd"
  # - _OPTIONS_CD is set

  _BUILTIN_NAME=cd
  _BUILTIN_HELP=$(echo $(help $_BUILTIN_NAME 2>&1))
  if [[ $_BUILTIN_HELP =~ "no help topics match" ]]
  then
    _show_error "required builtin \"$_BUILTIN_NAME\" not supported"
  else
    _BUILTIN_OPTION=-P
    if [[ " $_BUILTIN_HELP " =~ " $_BUILTIN_OPTION " ]]
    then
      _OPTIONS_CD=$_BUILTIN_OPTION
#      _eko_v "                 \$_OPTIONS_CD: \"$_OPTIONS_CD\""
      _eko_pv "\$_OPTIONS_CD:" \""$_OPTIONS_CD\""
    fi
  fi
  #- cd -#

  # - be explicit for clarity. we'll be testing this variable further below
  unset _OPTIONS_PWD

  #+ pwd +#
  # - "help pwd". stdout
  #   "-P"
  # - called in "function _pathname_transform_cd_pwd"
  # - _OPTIONS_PWD is set

  _BUILTIN_NAME=pwd
  _BUILTIN_HELP=$(echo $(help $_BUILTIN_NAME 2>&1))
  if [[ $_BUILTIN_HELP =~ "no help topics match" ]]
  then
    _show_error "required builtin \"$_BUILTIN_NAME\" not supported"
  else
    _BUILTIN_OPTION=-P
    if [[ " $_BUILTIN_HELP " =~ " $_BUILTIN_OPTION " ]]
    then
      _OPTIONS_PWD=$_BUILTIN_OPTION
#      _eko_v "                \$_OPTIONS_PWD: \"$_OPTIONS_PWD\""
      _eko_pv "\$_OPTIONS_PWD:" \""$_OPTIONS_PWD\""
    fi
  fi
  #- pwd -#

  # - _FUNCTION_TRANSFORM is set to _pathname_transform_cd_pwd (1/3)
  # - "-n string" = true if the length of string is non-zero
  if [[ -n $_OPTIONS_CD ]] \
  || [[ -n $_OPTIONS_PWD ]]
  then
    _FUNCTION_TRANSFORM=_pathname_transform_cd_pwd
#    _eko_v "         \$_FUNCTION_TRANSFORM: \"$_FUNCTION_TRANSFORM\""
    _eko_pv "\$_FUNCTION_TRANSFORM:" \""$_FUNCTION_TRANSFORM\""
  fi

  #+ read +#
  # - "help read". stdout
  #   "-r"
  # - called in "function _pathnames_scan"
  # - _OPTIONS_READ is set

  _BUILTIN_NAME=read
  _BUILTIN_HELP=$(echo $(help $_BUILTIN_NAME 2>&1))
  if [[ $_BUILTIN_HELP =~ "no help topics match" ]]
  then
    _show_error "required builtin \"$_BUILTIN_NAME\" not supported"
  else
    _BUILTIN_OPTION=-r
    if [[ " $_BUILTIN_HELP " =~ " $_BUILTIN_OPTION " ]]
    then
      _OPTIONS_READ=$_BUILTIN_OPTION
#      _eko_v "               \$_OPTIONS_READ: \"$_OPTIONS_READ\""
      _eko_pv "\$_OPTIONS_READ:" \""$_OPTIONS_READ\""
    else
      _show_error \""$_BUILTIN_NAME\" does not support \"$_BUILTIN_OPTION\""
    fi
  fi
  #- read -#

  _eko_iod "#- _builtin_validate_setup -#"
}

function _eko_iod()
{
  #+ _eko_iod +#

  # functions:
  # (none)

  # variables:
  # #
  # @
  # FUNCNAME (single dimension indexed array)
  # _BOOLEAN_DEBUG

  # NOTE:
  # - why $(( ${#FUNCNAME[@]} - 3 ))? to account for main, parent, current
  # - pay special attention to the "*" in "%*s". it's part of the magic

  if $_BOOLEAN_DEBUG
  then
    # - fast & fancy indenting/"outdenting"
    # - $((expression))
    # - ${#parameter}
    printf "%*s" $(( ${#FUNCNAME[@]} - 3 ))

    echo "$@"
  fi

  #- _eko_iod -#
}

function _eko_pv()
{
  #+ _eko_pv +#

  # functions:
  # (none)

  # variables:
  # @
  # _BOOLEAN_VERBOSE

  if $_BOOLEAN_VERBOSE
  then
    printf "%30s %s\n" "$1" "$2"
  fi

  #- _eko_pv -#
}

function _eko_v()
{
  #+ _eko_v +#

  # functions:
  # (none)

  # variables:
  # @
  # _BOOLEAN_VERBOSE

  if $_BOOLEAN_VERBOSE
  then
    echo "$@"
  fi

  #- _eko_v -#
}

function _parse_parameters()
{
  #+ _parse_parameters +#

  # functions:
  # _binary_validate_setup
  # _builtin_validate_setup
  # _eko_iod
  # _eko_pv
#  # _eko_v
  # _pathname_redundant_check
  # _pathname_validate
  # _pathnames_scan
  # _show_error
  # _show_help
  # _show_warning

  # variables:
  # #
  # 1
  # 2
  # @
  # _ARRAY_ELEMENT_HN (counter)
  # _ARRAY_HOLDNAMES (single dimension indexed array)
  # _ARRAY_PATHNAMES (single dimension indexed array)
  # _BOOLEAN_DEBUG
  # _BOOLEAN_DRYRUN
  # _BOOLEAN_ERROR
  # _BOOLEAN_HARDLINK
  # _BOOLEAN_LONG
  # _BOOLEAN_MD5SUM
  # _BOOLEAN_NANOSECONDS
  # _BOOLEAN_NONSPARSE
  # _BOOLEAN_RELATIVE
  # _BOOLEAN_SHA1SUM
  # _BOOLEAN_SHA224SUM
  # _BOOLEAN_SHA256SUM
  # _BOOLEAN_SHA384SUM
  # _BOOLEAN_SHA512SUM
  # _BOOLEAN_SPARSE
  # _BOOLEAN_STDOUT
  # _BOOLEAN_SUM
  # _BOOLEAN_UNLINK
  # _BOOLEAN_VERBOSE
  # _BOOLEAN_XDEV
  # _FUNCTION_SUM (_pathname_md5sum_md5sum _pathname_openssl_md5sum _pathname_openssl_sha1sum _pathname_openssl_sha224sum _pathname_openssl_sha256sum _pathname_openssl_sha384sum _pathname_openssl_sha512sum _pathname_sha1sum_sha1sum _pathname_sha224sum_sha224sum _pathname_sha256sum_sha256sum _pathname_sha384sum_sha384sum _pathname_sha512sum_sha512sum)
  # _FUNCTION_TRANSFORM (_pathname_transform_bruteforce _pathname_transform_cd_pwd _pathname_transform_realpath)
  # _OPTIONS_CD (cd options, not script options)
  # _OPTIONS_CP (cp options, not script options)
  # _OPTIONS_LN (ln options, not script options)
  # _OPTIONS_MV (mv options, not script options)
  # _OPTIONS_PWD (pwd options, not script options)
  # _OPTIONS_READ (read options, not script options)
  # _OPTIONS_REALPATH (realpath options, not script options)
  # _OPTIONS_RM (rm options, not script options)
  # _OPTION_PATHNAME
  # _OPTION_SUM_SIZE

  # NOTE:
  # - boolean variables are proper toggles

  # NOTE:
  # - _BOOLEAN_STDOUT is special. it's quite simple to set up initially

  # - _BOOLEAN_STDOUT
  # - companion functions: none. used directly in "function _pathnames_scan"
  # - default: true
  # - *not* toggled in while/do/done loop like the others
  # - immediately *after* the while/do/done loop _BOOLEAN_STDOUT is set to
  #   false if any of $_BOOLEAN_DEBUG, $_BOOLEAN_LONG, or $_BOOLEAN_VERBOSE
  #   are true

  #+ parameter defaults +#

  _BOOLEAN_DEBUG=false       # display
  _BOOLEAN_DRYRUN=false      # control
  _BOOLEAN_ERROR=false       # undefined
  _BOOLEAN_HARDLINK=false    # action
  _BOOLEAN_LONG=false        # display
  _BOOLEAN_MD5SUM=false      # action
  _BOOLEAN_NANOSECONDS=false # display
  _BOOLEAN_NONSPARSE=false   # action
  _BOOLEAN_RELATIVE=false    # action
  _BOOLEAN_SHA1SUM=false     # action
  _BOOLEAN_SHA224SUM=false   # action
  _BOOLEAN_SHA256SUM=false   # action
  _BOOLEAN_SHA384SUM=false   # action
  _BOOLEAN_SHA512SUM=false   # action
  _BOOLEAN_SPARSE=false      # action
  _BOOLEAN_STDOUT=true       # display
  _BOOLEAN_SUM=false         # action
  _BOOLEAN_UNLINK=false      # action
  _BOOLEAN_VERBOSE=false     # display
  _BOOLEAN_XDEV=false        # action
  unset _ARRAY_HOLDNAMES
  unset _ARRAY_PATHNAMES
  unset _OPTION_PATHNAME
  unset _OPTION_SUM_SIZE

  #- parameter defaults -#

  # NOTE:
  # - perform minimal checks in the loop & additional checks after the loop.
  #   why? to permit variables to "settle" if specified multiple times & to
  #   permit options that rely on eachother (ie: "-m, --md5sum" & "-s, --size")
  #   as well as options that conflict (ie: "-H, --hardlink" & "-U, --unlink")
  #   to be specified in any order
  # - "-p, --pathname" is an exception. it's additive, not a toggle. hence the
  #   array

  while [[ $# -gt 0 ]]
  do
    case $1 in
      ( -1 \
      | --sha1sum )
        if $_BOOLEAN_SHA1SUM
        then
          _BOOLEAN_SHA1SUM=false
        else
          _BOOLEAN_SHA1SUM=true
        fi
#+ marker *sum conflict type +#
if [[ 1 == 1 ]]
then
        if $_BOOLEAN_SHA1SUM
        then
          if $_BOOLEAN_SUM
          then
            _show_error "sha1sum conflict"
          else
            _BOOLEAN_SUM=true
          fi
        fi
fi
#- marker *sum conflict type -#
      ;;
      ( -224 \
      | --sha224sum )
        if $_BOOLEAN_SHA224SUM
        then
          _BOOLEAN_SHA224SUM=false
        else
          _BOOLEAN_SHA224SUM=true
        fi
#+ marker *sum conflict type +#
if [[ 1 == 1 ]]
then
        if $_BOOLEAN_SHA224SUM
        then
          if $_BOOLEAN_SUM
          then
            _show_error "sha224sum conflict"
          else
            _BOOLEAN_SUM=true
          fi
        fi
fi
#- marker *sum conflict type -#
      ;;
      ( -256 \
      | --sha256sum )
        if $_BOOLEAN_SHA256SUM
        then
          _BOOLEAN_SHA256SUM=false
        else
          _BOOLEAN_SHA256SUM=true
        fi
#+ marker *sum conflict type +#
if [[ 1 == 1 ]]
then
        if $_BOOLEAN_SHA256SUM
        then
          if $_BOOLEAN_SUM
          then
            _show_error "sha256sum conflict"
          else
            _BOOLEAN_SUM=true
          fi
        fi
fi
#- marker *sum conflict type -#
      ;;
      ( -384 \
      | --sha384sum )
        if $_BOOLEAN_SHA384SUM
        then
          _BOOLEAN_SHA384SUM=false
        else
          _BOOLEAN_SHA384SUM=true
        fi
#+ marker *sum conflict type +#
if [[ 1 == 1 ]]
then
        if $_BOOLEAN_SHA384SUM
        then
          if $_BOOLEAN_SUM
          then
            _show_error "sha384sum conflict"
          else
            _BOOLEAN_SUM=true
          fi
        fi
fi
#- marker *sum conflict type -#
      ;;
      ( -512 \
      | --sha512sum )
        if $_BOOLEAN_SHA512SUM
        then
          _BOOLEAN_SHA512SUM=false
        else
          _BOOLEAN_SHA512SUM=true
        fi
#+ marker *sum conflict type +#
if [[ 1 == 1 ]]
then
        if $_BOOLEAN_SHA512SUM
        then
          if $_BOOLEAN_SUM
          then
            _show_error "sha512sum conflict"
          else
            _BOOLEAN_SUM=true
          fi
        fi
fi
#- marker *sum conflict type -#
      ;;
      ( -D \
      | --dry-run )
        if $_BOOLEAN_DRYRUN
        then
          _BOOLEAN_DRYRUN=false
        else
          _BOOLEAN_DRYRUN=true
        fi
      ;;
      ( -E \
      | --error )
        if $_BOOLEAN_ERROR
        then
          _BOOLEAN_ERROR=false
        else
          _BOOLEAN_ERROR=true
        fi
      ;;
      ( -H \
      | --hardlink )
        if $_BOOLEAN_HARDLINK
        then
          _BOOLEAN_HARDLINK=false
        else
          _BOOLEAN_HARDLINK=true
        fi
      ;;
      ( -N \
      | --non-sparse )
        if $_BOOLEAN_NONSPARSE
        then
          _BOOLEAN_NONSPARSE=false
        else
          _BOOLEAN_NONSPARSE=true
        fi
      ;;
      ( -S \
      | --sparse )
        if $_BOOLEAN_SPARSE
        then
          _BOOLEAN_SPARSE=false
        else
          _BOOLEAN_SPARSE=true
        fi
      ;;
      ( -U \
      | --unlink )
        if $_BOOLEAN_UNLINK
        then
          _BOOLEAN_UNLINK=false
        else
          _BOOLEAN_UNLINK=true
        fi
      ;;
      ( -W \
      | -w \
      | --warning )
        _show_warning
      ;;
      ( -d \
      | --debug )
        if $_BOOLEAN_DEBUG
        then
          _BOOLEAN_DEBUG=false
        else
          _BOOLEAN_DEBUG=true
        fi
      ;;
      ( -l \
      | --long )
        if $_BOOLEAN_LONG
        then
          _BOOLEAN_LONG=false
        else
          _BOOLEAN_LONG=true
        fi
      ;;
      ( -m \
      | --md5sum )
        if $_BOOLEAN_MD5SUM
        then
          _BOOLEAN_MD5SUM=false
        else
          _BOOLEAN_MD5SUM=true
        fi
#+ marker *sum conflict type +#
if [[ 1 == 1 ]]
then
        if $_BOOLEAN_MD5SUM
        then
          if $_BOOLEAN_SUM
          then
            _show_error "md5sum conflict"
          else
            _BOOLEAN_SUM=true
          fi
        fi
fi
#- marker *sum conflict type -#
      ;;
      ( -n \
      | --nanoseconds )
        if $_BOOLEAN_NANOSECONDS
        then
          _BOOLEAN_NANOSECONDS=false
        else
          _BOOLEAN_NANOSECONDS=true
        fi
      ;;
      ( -p \
      | --pathname )
        # - ${parameter:offset:length}
        # - "-z string" = true if the length of string is zero
        if [[ ${2:0:1} == - ]] \
        || [[ -z $2 ]]
        then
          _show_error "pathname not specified"
        else
          # - keep adding paths until another option is specified or until
          #   we've reached the end of the commandline
          # - globs are now supported. refer to bash(1) section
          #   "Pattern Matching" for additional details
          # - (special thanks to dive in OFTC #slackware for sparking the idea
          #   of adding glob support)
          # - ${parameter:offset:length}
          # - "-z string" = true if the length of string is zero
          until [[ ${2:0:1} == - ]] \
          || [[ -z $2 ]]
          do
            # - blindly save what was passed. it will be tested after the loop
            _ARRAY_HOLDNAMES+=( "$2" )
            shift
          done
        fi
        # - (special thanks to karlmag in OFTC #slackware for finding the
        #   troublemaker below: "you're shifting too much :-P")
        #shift
      ;;
      ( -r \
      | --relative )
        if $_BOOLEAN_RELATIVE
        then
          _BOOLEAN_RELATIVE=false
        else
          _BOOLEAN_RELATIVE=true
        fi
      ;;
      ( -s \
      | --size )
        # - ${parameter:offset:length}
        # - "-z string" = true if the length of string is zero
        if [[ ${2:0:1} == - ]] \
        || [[ -z $2 ]]
        then
          _show_error "*sum buffer size not specified"
        else
#+ marker *sum conflict size +#
if [[ 1 == 1 ]]
then
          # - "-n string" = true if the length of string is non-zero
          if [[ -n $_OPTION_SUM_SIZE ]]
          then
            _show_error "*sum buffer size previously specified"
          else
            _OPTION_SUM_SIZE=$2
          fi
else
          _OPTION_SUM_SIZE=$2
fi
#- marker *sum conflict size -#
        fi
        shift
      ;;
      ( -v \
      | --verbose )
        if $_BOOLEAN_VERBOSE
        then
          _BOOLEAN_VERBOSE=false
        else
          _BOOLEAN_VERBOSE=true
        fi
      ;;
      ( -x \
      | --xdev )
        if $_BOOLEAN_XDEV
        then
          _BOOLEAN_XDEV=false
        else
          _BOOLEAN_XDEV=true
        fi
      ;;
      ( "-?" \
      | -h \
      | --help ) # -? must be "-?" or it matches "-<any single character>"
        _show_help
      ;;
      ( -* )
        _show_error "invalid option \"$1\" specified"
      ;;
      ( * )
        _show_error "invalid parameter \"$1\" specified"
      ;;
    esac
    shift
  done

#+ marker *sum conflict type +#
# - why do this? if any single 1 of the 6 *sum types is specified exactly
#   twice on the commandline, the boolean for that individual *sum type will
#   be toggled back & forth to "false", but _BOOLEAN_SUM will be set to "true",
#   causing _FUNCTION_SUM (defined as "" at this point) to be uselessly called
#   in the most time critical function ("function _pathnames_scan")
if [[ 1 == 1 ]]
then
  if ! $_BOOLEAN_MD5SUM \
  && ! $_BOOLEAN_SHA1SUM \
  && ! $_BOOLEAN_SHA224SUM \
  && ! $_BOOLEAN_SHA256SUM \
  && ! $_BOOLEAN_SHA384SUM \
  && ! $_BOOLEAN_SHA512SUM \
  && $_BOOLEAN_SUM
  then
    _BOOLEAN_SUM=false
  fi
fi
#- marker *sum conflict type -#

#+ marker *sum dry-run +#
if [[ 1 == 1 ]]
then
  if $_BOOLEAN_DRYRUN
  then
    _BOOLEAN_SUM=false
  fi
fi
#- marker *sum dry-run -#

  #- _parse_parameters -#

  # - technically in the wrong spot, but it's a chicken or egg scenario
  _eko_iod "#+ _parse_parameters +#"

  # NOTE:
  # - order of operations of the following 2 functions is important because of
  #   the ranking necessary for the 3 _pathname_transform_* functions

  # - validate the existence & required options of system builtins
  # - while we're at it, set up the options for the various builtins if needed
  _builtin_validate_setup

  # - validate the existence & required options of system binaries
  # - while we're at it, set up the options for the various binaries if needed
  _binary_validate_setup

  _ARRAY_ELEMENT_HN=0
  while [[ $_ARRAY_ELEMENT_HN -lt ${#_ARRAY_HOLDNAMES[@]} ]]
  do
    # - process what was passed on the commandline
    # - precedes: _pathname_validate
    _OPTION_PATHNAME="${_ARRAY_HOLDNAMES[$_ARRAY_ELEMENT_HN]}"

    # - succeeds: _OPTION_PATHNAME assignment
    # - precedes: $_FUNCTION_TRANSFORM
    # - ensure it's a valid pathname
    _pathname_validate

    # - succeeds: _pathname_validate
    # - precedes: _pathname_redundant_check
    # - transform $_OPTION_PATHNAME specified on the commandline
    $_FUNCTION_TRANSFORM

    # - succeeds: $_FUNCTION_TRANSFORM
    # - precedes: _ARRAY_PATHNAMES assignment
    # - ensure there are no redundant paths
    _pathname_redundant_check

    # - succeeds: _pathname_redundant_check
    # - this entire segment is "fall through"
    # ^ if everything passes, append $_OPTION_PATHNAME to _ARRAY_PATHNAMES
   _ARRAY_PATHNAMES+=( "$_OPTION_PATHNAME" )

    # - not really necessary, but leaves it in a predictable state
    unset _OPTION_PATHNAME

    # - ((expression))
    # - id++ = variable post-increment
    ((_ARRAY_ELEMENT_HN++))
  done

  #+ parameter settings (in (mostly) proper order of operation) +#

  # NOTE:
  # - the following blocks are *very* sensitive to order of operations

  if $_BOOLEAN_DEBUG \
  || $_BOOLEAN_LONG \
  || $_BOOLEAN_VERBOSE
  then
    _BOOLEAN_STDOUT=false      # display
  fi

#  _eko_v "              \$_BOOLEAN_DEBUG: \"$_BOOLEAN_DEBUG\""
#  _eko_v "             \$_BOOLEAN_DRYRUN: \"$_BOOLEAN_DRYRUN\""
#  _eko_v "              \$_BOOLEAN_ERROR: \"$_BOOLEAN_ERROR\""
#  _eko_v "           \$_BOOLEAN_HARDLINK: \"$_BOOLEAN_HARDLINK\""
#  _eko_v "               \$_BOOLEAN_LONG: \"$_BOOLEAN_LONG\""
#  _eko_v "             \$_BOOLEAN_MD5SUM: \"$_BOOLEAN_MD5SUM\""
#  _eko_v "        \$_BOOLEAN_NANOSECONDS: \"$_BOOLEAN_NANOSECONDS\""
#  _eko_v "          \$_BOOLEAN_NONSPARSE: \"$_BOOLEAN_NONSPARSE\""
#  _eko_v "           \$_BOOLEAN_RELATIVE: \"$_BOOLEAN_RELATIVE\""
#  _eko_v "            \$_BOOLEAN_SHA1SUM: \"$_BOOLEAN_SHA1SUM\""
#  _eko_v "          \$_BOOLEAN_SHA224SUM: \"$_BOOLEAN_SHA224SUM\""
#  _eko_v "          \$_BOOLEAN_SHA256SUM: \"$_BOOLEAN_SHA256SUM\""
#  _eko_v "          \$_BOOLEAN_SHA384SUM: \"$_BOOLEAN_SHA384SUM\""
#  _eko_v "          \$_BOOLEAN_SHA512SUM: \"$_BOOLEAN_SHA512SUM\""
#  _eko_v "             \$_BOOLEAN_SPARSE: \"$_BOOLEAN_SPARSE\""
#  _eko_v "             \$_BOOLEAN_STDOUT: \"$_BOOLEAN_STDOUT\""
#  _eko_v "                \$_BOOLEAN_SUM: \"$_BOOLEAN_SUM\""
#  _eko_v "             \$_BOOLEAN_UNLINK: \"$_BOOLEAN_UNLINK\""
#  _eko_v "            \$_BOOLEAN_VERBOSE: \"$_BOOLEAN_VERBOSE\""
#  _eko_v "               \$_BOOLEAN_XDEV: \"$_BOOLEAN_XDEV\""
#  _eko_v "               \$_FUNCTION_SUM: \"$_FUNCTION_SUM\""
#  _eko_v "         \$_FUNCTION_TRANSFORM: \"$_FUNCTION_TRANSFORM\""
#  _eko_v "                 \$_OPTIONS_CD: \"$_OPTIONS_CD\""
#  _eko_v "                 \$_OPTIONS_CP: \"$_OPTIONS_CP\""
#  _eko_v "                 \$_OPTIONS_LN: \"$_OPTIONS_LN\""
#  _eko_v "                 \$_OPTIONS_MV: \"$_OPTIONS_MV\""
#  _eko_v "                \$_OPTIONS_PWD: \"$_OPTIONS_PWD\""
#  _eko_v "               \$_OPTIONS_READ: \"$_OPTIONS_READ\""
#  _eko_v "           \$_OPTIONS_REALPATH: \"$_OPTIONS_REALPATH\""
#  _eko_v "                 \$_OPTIONS_RM: \"$_OPTIONS_RM\""
#  _eko_v "            \$_OPTION_SUM_SIZE: \"$_OPTION_SUM_SIZE\""
#  _eko_v "      \${#_ARRAY_PATHNAMES[@]}: \"${#_ARRAY_PATHNAMES[@]}\""
#  _eko_v "       \${_ARRAY_PATHNAMES[@]}: \"${_ARRAY_PATHNAMES[@]}\""
  _eko_pv "\$_BOOLEAN_DEBUG:" \""$_BOOLEAN_DEBUG\""
  _eko_pv "\$_BOOLEAN_DRYRUN:" \""$_BOOLEAN_DRYRUN\""
  _eko_pv "\$_BOOLEAN_ERROR:" \""$_BOOLEAN_ERROR\""
  _eko_pv "\$_BOOLEAN_HARDLINK:" \""$_BOOLEAN_HARDLINK\""
  _eko_pv "\$_BOOLEAN_LONG:" \""$_BOOLEAN_LONG\""
  _eko_pv "\$_BOOLEAN_MD5SUM:" \""$_BOOLEAN_MD5SUM\""
  _eko_pv "\$_BOOLEAN_NANOSECONDS:" \""$_BOOLEAN_NANOSECONDS\""
  _eko_pv "\$_BOOLEAN_NONSPARSE:" \""$_BOOLEAN_NONSPARSE\""
  _eko_pv "\$_BOOLEAN_RELATIVE:" \""$_BOOLEAN_RELATIVE\""
  _eko_pv "\$_BOOLEAN_SHA1SUM:" \""$_BOOLEAN_SHA1SUM\""
  _eko_pv "\$_BOOLEAN_SHA224SUM:" \""$_BOOLEAN_SHA224SUM\""
  _eko_pv "\$_BOOLEAN_SHA256SUM:" \""$_BOOLEAN_SHA256SUM\""
  _eko_pv "\$_BOOLEAN_SHA384SUM:" \""$_BOOLEAN_SHA384SUM\""
  _eko_pv "\$_BOOLEAN_SHA512SUM:" \""$_BOOLEAN_SHA512SUM\""
  _eko_pv "\$_BOOLEAN_SPARSE:" \""$_BOOLEAN_SPARSE\""
  _eko_pv "\$_BOOLEAN_STDOUT:" \""$_BOOLEAN_STDOUT\""
  _eko_pv "\$_BOOLEAN_SUM:" \""$_BOOLEAN_SUM\""
  _eko_pv "\$_BOOLEAN_UNLINK:" \""$_BOOLEAN_UNLINK\""
  _eko_pv "\$_BOOLEAN_VERBOSE:" \""$_BOOLEAN_VERBOSE\""
  _eko_pv "\$_BOOLEAN_XDEV:" \""$_BOOLEAN_XDEV\""
  _eko_pv "\$_FUNCTION_SUM:" \""$_FUNCTION_SUM\""
  _eko_pv "\$_FUNCTION_TRANSFORM:" \""$_FUNCTION_TRANSFORM\""
  _eko_pv "\$_OPTIONS_CD:" \""$_OPTIONS_CD\""
  _eko_pv "\$_OPTIONS_CP:" \""$_OPTIONS_CP\""
  _eko_pv "\$_OPTIONS_LN:" \""$_OPTIONS_LN\""
  _eko_pv "\$_OPTIONS_MV:" \""$_OPTIONS_MV\""
  _eko_pv "\$_OPTIONS_PWD:" \""$_OPTIONS_PWD\""
  _eko_pv "\$_OPTIONS_READ:" \""$_OPTIONS_READ\""
  _eko_pv "\$_OPTIONS_REALPATH:" \""$_OPTIONS_REALPATH\""
  _eko_pv "\$_OPTIONS_RM:" \""$_OPTIONS_RM\""
  _eko_pv "\$_OPTION_SUM_SIZE:" \""$_OPTION_SUM_SIZE\""
  _eko_pv "\${#_ARRAY_PATHNAMES[@]}:" \""${#_ARRAY_PATHNAMES[@]}\""
  _eko_pv "\${_ARRAY_PATHNAMES[@]}:" \""${_ARRAY_PATHNAMES[@]}\""

  # NOTE:
  # - lots of testing before we go further:
  # - done here:
  # - "-p" not specified at all. show help
  # - multiple "-p" & "-r" are mutually exclusive. error exit
  # - "-s" specified without "-m/-1/-224/-256/-384/-512" (1/2). error exit
  # - "-s" specified with non-numeric (2/2). error exit
  # - "-n" specified without "-l" or "-v". error exit
  # - "-N" specified without "-U". error exit
  # - "-S" specified without "-U". error exit
  # - "-H" & "-r" are mutually exclusive. error exit
  # - "-H" & "-U" are mutually exclusive. error exit
  # - "-N" & "-S" are mutually exclusive. error exit
  # - "-d" & "-l" & "-m/-1/-224/-256/-384/-512" are mutually exclusive. error exit
  # - "-l" & "-v" are mutually exclusive. error exit
  # - done elsewhere:
  # - path exists?
  # - path is a directory?
  # - path is readable? (necessary for hardlinking/scanning/unlinking)
  # - path is writable? (necessary for hardlinking/unlinking)
  # ^ these 4 tests are in "function _pathname_validate"

  # - I *think* this covers all the bases
  # - these tests need to be done in a (more or less) specific order

  # - "-p" not specified at all
  if [[ ${#_ARRAY_PATHNAMES[@]} -eq 0 ]]
  then
    _show_help
  fi

  # - multiple "-p" & "-r" are mutually exclusive
  if [[ ${#_ARRAY_PATHNAMES[@]} -gt 1 ]] \
  && $_BOOLEAN_RELATIVE
  then
    _show_error "multiple \"-p, --pathname\" & \"-r, --relative\" are mutually exclusive"
  fi

  # - *sum (1/2)
  # - "-s" specified without "-m/-1/-224/-256/-384/-512" (1/2)
  # - "-n string" = true if the length of string is non-zero
  if [[ -n $_OPTION_SUM_SIZE ]] \
  && ! $_BOOLEAN_SUM
  then
    _show_error \""-m/-1/-224/-256/-384/-512\" not specified"
  fi

  # - *sum (2/2)
  # - "-s" specified with non-numeric (2/2)
  # - ensure it's a whole positive number (anything else prefixed with "-" is
  #   caught during the parsing loop above)
  # - "-n string" = true if the length of string is non-zero
  if [[ -n $_OPTION_SUM_SIZE ]] \
  && [[ ! $_OPTION_SUM_SIZE =~ ^[0-9]+$ ]]
  then
    _show_error "invalid *sum buffer size \"$_OPTION_SUM_SIZE\" specified"
  fi

  # - simple logic: one requires one of the others
  # - "-n" specified without "-l" or "-v"
  if $_BOOLEAN_NANOSECONDS \
  && ! ( $_BOOLEAN_LONG \
  || $_BOOLEAN_VERBOSE )
  then
    _show_error \""-n, --nanoseconds\" specified without \"-l, --long\" or \"-v, --verbose\""
  fi

  # - simple logic: one requires the other
  # - "-N" specified without "-U"
  if $_BOOLEAN_NONSPARSE \
  && ! $_BOOLEAN_UNLINK
  then
    _show_error \""-N, --non-sparse\" specified without \"-U, --unlink\""
  fi

  # - simple logic: one requires the other
  # - "-S" specified without "-U"
  if $_BOOLEAN_SPARSE \
  && ! $_BOOLEAN_UNLINK
  then
    _show_error \""-S, --sparse\" specified without \"-U, --unlink\""
  fi

  # - absolute paths will be needed in the sqlite3 db
  # - "-H" & "-r" are mutually exclusive
  if $_BOOLEAN_HARDLINK \
  && $_BOOLEAN_RELATIVE
  then
    _show_error \""-H, --hardlink\" & \"-r, --relative\" are mutually exclusive"
  fi

  # - simple logic: these are completely opposite actions
  # - "-H" & "-U" are mutually exclusive
  if $_BOOLEAN_HARDLINK \
  && $_BOOLEAN_UNLINK
  then
    _show_error \""-H, --hardlink\" & \"-U, --unlink\" are mutually exclusive"
  fi

  # - simple logic: these are completely opposite actions
  # - "-N" & "-S" are mutually exclusive
  if $_BOOLEAN_NONSPARSE \
  && $_BOOLEAN_SPARSE
  then
    _show_error \""-N, --non-sparse\" & \"-S, --sparse\" are mutually exclusive"
  fi

  # - cosmetic: stdout is extremely garbled
  # - "-d" & "-l" & "-m/-1/-224/-256/-384/-512" are mutually exclusive
  if $_BOOLEAN_DEBUG \
  && $_BOOLEAN_LONG \
  && $_BOOLEAN_SUM
  then
    _show_error \""-d\" & \"-l\" & \"-m/-1/-224/-256/-384/-512\" are mutually exclusive"
  fi

  # - cosmetic: stdout is extremely garbled
  # - "-l" & "-v" are mutually exclusive
  if $_BOOLEAN_LONG \
  && $_BOOLEAN_VERBOSE
  then
    _show_error \""-l, --long\" & \"-v, --verbose\" are mutually exclusive"
  fi

  #- parameter settings (in (mostly) proper order of operation) -#

  # - this function is "fall through"
  # ^ if everything passes, perform the scan
  _pathnames_scan

  _eko_iod "#- _parse_parameters -#"
}

function _pathname_md5sum_md5sum()
{
  _eko_iod "#+ _pathname_md5sum_md5sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # md5sum

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(md5sum -- "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "  <pathname>" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  "$_ST_NAME"/}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | md5sum -- -)

    # - ${parameter/pattern/string}
    # - strip "  -" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  -/}
  fi

  _eko_iod "#- _pathname_md5sum_md5sum -#"
}

function _pathname_openssl_md5sum()
{
  _eko_iod "#+ _pathname_openssl_md5sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(openssl dgst -md5 "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "MD5(<pathname>)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#MD5("$_ST_NAME")= /}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -md5)

    # - ${parameter/pattern/string}
    # - strip "(stdin)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#(stdin)= /}
  fi

  _eko_iod "#- _pathname_openssl_md5sum -#"
}

function _pathname_openssl_sha1sum()
{
  _eko_iod "#+ _pathname_openssl_sha1sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(openssl dgst -sha1 "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "SHA1(<pathname>)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#SHA1("$_ST_NAME")= /}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -sha1)

    # - ${parameter/pattern/string}
    # - strip "(stdin)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#(stdin)= /}
  fi

  _eko_iod "#- _pathname_openssl_sha1sum -#"
}

function _pathname_openssl_sha224sum()
{
  _eko_iod "#+ _pathname_openssl_sha224sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(openssl dgst -sha224 "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "SHA224(<pathname>)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#SHA224("$_ST_NAME")= /}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -sha224)

    # - ${parameter/pattern/string}
    # - strip "(stdin)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#(stdin)= /}
  fi

  _eko_iod "#- _pathname_openssl_sha224sum -#"
}

function _pathname_openssl_sha256sum()
{
  _eko_iod "#+ _pathname_openssl_sha256sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(openssl dgst -sha256 "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "SHA256(<pathname>)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#SHA256("$_ST_NAME")= /}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -sha256)

    # - ${parameter/pattern/string}
    # - strip "(stdin)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#(stdin)= /}
  fi

  _eko_iod "#- _pathname_openssl_sha256sum -#"
}

function _pathname_openssl_sha384sum()
{
  _eko_iod "#+ _pathname_openssl_sha384sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(openssl dgst -sha384 "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "SHA384(<pathname>)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#SHA384("$_ST_NAME")= /}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -sha384)

    # - ${parameter/pattern/string}
    # - strip "(stdin)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#(stdin)= /}
  fi

  _eko_iod "#- _pathname_openssl_sha384sum -#"
}

function _pathname_openssl_sha512sum()
{
  _eko_iod "#+ _pathname_openssl_sha512sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # openssl (fallback to supported *sum variants: md5 & sha1/224/256/384/512)

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(openssl dgst -sha512 "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "SHA512(<pathname>)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#SHA512("$_ST_NAME")= /}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | openssl dgst -sha512)

    # - ${parameter/pattern/string}
    # - strip "(stdin)= " prefix from output. keep the rest
    _ST_SUM=${_ST_SUM/#(stdin)= /}
  fi

  _eko_iod "#- _pathname_openssl_sha512sum -#"
}

function _pathname_redundant_check()
{
  _eko_iod "#+ _pathname_redundant_check +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v
  # _show_error

  # variables:
  # #
  # @
  # _ARRAY_ELEMENT_PN (counter)
  # _ARRAY_PATHNAMES (single dimension indexed array)
  # _LHS
  # _LLEN
  # _MIN_LEN
  # _OPTION_PATHNAME
  # _RHS
  # _RLEN

  # NOTE:
  # - succeeds: $_FUNCTION_TRANSFORM
  # - precedes: _ARRAY_PATHNAMES assignment
  # - this function processes only path prefixes (as opposed to path suffixes)
  #   so slow & careful is perfectly acceptable. it *must* be absolutely 100%
  #   accurate
  # - this function is "fall through"
  # ^ if $_OPTION_PATHNAME passes all of the following tests, it's considered
  #   valid

#  _eko_v "            \$_OPTION_PATHNAME: \"$_OPTION_PATHNAME\""
#  _eko_v "      \${#_ARRAY_PATHNAMES[@]}: \"${#_ARRAY_PATHNAMES[@]}\""
#  _eko_v "       \${_ARRAY_PATHNAMES[@]}: \"${_ARRAY_PATHNAMES[@]}\""
  _eko_pv "\$_OPTION_PATHNAME:" \""$_OPTION_PATHNAME\""
  _eko_pv "\${#_ARRAY_PATHNAMES[@]}:" \""${#_ARRAY_PATHNAMES[@]}\""
  _eko_pv "\${_ARRAY_PATHNAMES[@]}:" \""${_ARRAY_PATHNAMES[@]}\""

  # - reassign so the original variable remains unmodified
  # - conditionally append a trailing "/" while we're at it
  #   (the "/" is very important)
  if [[ "$_OPTION_PATHNAME" == / ]]
  then
    _LHS=/
  else
    _LHS="$_OPTION_PATHNAME/"
  fi

  # - get length
  _LLEN=${#_LHS}

  _ARRAY_ELEMENT_PN=0
  while [[ $_ARRAY_ELEMENT_PN -lt ${#_ARRAY_PATHNAMES[@]} ]]
  do
    # - reassign so the original variable remains unmodified
    # - conditionally append a trailing "/" while we're at it
    #   (the "/" is very important)
    if [[ "${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}" == / ]]
    then
      _RHS=/
    else
      _RHS="${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}/"
    fi

    # - get length
    _RLEN=${#_RHS}

    # - we want the minimum length
    if [[ $_LLEN -lt $_RLEN ]]
    then
      _MIN_LEN=$_LLEN
    else
      _MIN_LEN=$_RLEN
    fi

    # - use reassigned variables (with "/") for the tests (above & below)
    # - use original variables (without "/") for the reports

    # NOTE:
    # - there are several possible combinations of reports. for the moment,
    #   "duplicate" & "child" are in use. it's simple enough for the 2nd & 3rd
    #   reports to use only "parent" or a combination of "parent/child"

    # - _LHS = option pathname, _RHS = single array pathnames element
    # - ${parameter:offset:length}
    if [[ "$_LHS" == "$_RHS" ]]
    then
      #_show_error \""${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}\" is a duplicate directory of \"$_OPTION_PATHNAME\""
      _show_error \""$_OPTION_PATHNAME\" is a duplicate directory of \"${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}\""
    elif [[ "$_LHS" == "${_RHS:0:$_MIN_LEN}" ]]
    then
      _show_error \""${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}\" is a child directory of \"$_OPTION_PATHNAME\""
      #_show_error \""$_OPTION_PATHNAME\" is a parent directory of \"${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}\""
    elif [[ "${_LHS:0:$_MIN_LEN}" == "$_RHS" ]]
    then
      #_show_error \""${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}\" is a parent directory of \"$_OPTION_PATHNAME\""
      _show_error \""$_OPTION_PATHNAME\" is a child directory of \"${_ARRAY_PATHNAMES[$_ARRAY_ELEMENT_PN]}\""
    fi

    # - ((expression))
    # - id++ = variable post-increment
    ((_ARRAY_ELEMENT_PN++))
  done

  _eko_iod "#- _pathname_redundant_check -#"
}

function _pathname_sha1sum_sha1sum()
{
  _eko_iod "#+ _pathname_sha1sum_sha1sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # sha1sum

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(sha1sum -- "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "  <pathname>" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  "$_ST_NAME"/}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | sha1sum -- -)

    # - ${parameter/pattern/string}
    # - strip "  -" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  -/}
  fi

  _eko_iod "#- _pathname_sha1sum_sha1sum -#"
}

function _pathname_sha224sum_sha224sum()
{
  _eko_iod "#+ _pathname_sha224sum_sha224sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # sha224sum

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(sha224sum -- "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "  <pathname>" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  "$_ST_NAME"/}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | sha224sum -- -)

    # - ${parameter/pattern/string}
    # - strip "  -" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  -/}
  fi

  _eko_iod "#- _pathname_sha224sum_sha224sum -#"
}

function _pathname_sha256sum_sha256sum()
{
  _eko_iod "#+ _pathname_sha256sum_sha256sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # sha256sum

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(sha256sum -- "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "  <pathname>" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  "$_ST_NAME"/}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | sha256sum -- -)

    # - ${parameter/pattern/string}
    # - strip "  -" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  -/}
  fi

  _eko_iod "#- _pathname_sha256sum_sha256sum -#"
}

function _pathname_sha384sum_sha384sum()
{
  _eko_iod "#+ _pathname_sha384sum_sha384sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # sha384sum

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(sha384sum -- "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "  <pathname>" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  "$_ST_NAME"/}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | sha384sum -- -)

    # - ${parameter/pattern/string}
    # - strip "  -" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  -/}
  fi

  _eko_iod "#- _pathname_sha384sum_sha384sum -#"
}

function _pathname_sha512sum_sha512sum()
{
  _eko_iod "#+ _pathname_sha512sum_sha512sum +#"

  # functions:
  # _eko_iod

  # variables:
  # _OPTION_SUM_SIZE
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_SUM (contrivance. not from stat(2))

  # binaries:
  # head
  # sha512sum

  # - "-z string" = true if the length of string is zero
  if [[ -z $_OPTION_SUM_SIZE ]]
  then
    # - generate *sum of the file (full)
    _ST_SUM=$(sha512sum -- "$_ST_NAME" 2>/dev/null)

    # - ${parameter/pattern/string}
    # - strip "  <pathname>" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  "$_ST_NAME"/}
  else
    # - generate *sum of the file ($_OPTION_SUM_SIZE)
    _ST_SUM=$(head --bytes=$_OPTION_SUM_SIZE -- "$_ST_NAME" 2>/dev/null | sha512sum -- -)

    # - ${parameter/pattern/string}
    # - strip "  -" suffix from output. keep the rest
    _ST_SUM=${_ST_SUM/%  -/}
  fi

  _eko_iod "#- _pathname_sha512sum_sha512sum -#"
}

function _pathname_transform_bruteforce()
{
  _eko_iod "#+ _pathname_transform_bruteforce +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v

  # variables:
  # _BASENAME
  # _DIRNAME
  # _LINKNAME
  # _OPTION_PATHNAME
  # _STRING_PATHNAME

  # binaries:
  # basename (fallback with dirname/find to realpath)
  # dirname (fallback with basename/find to realpath)
  # find

  # NOTE:
  # - succeeds: _pathname_validate
  # - precedes: _pathname_redundant_check
  # - entry: possibly sloppy $_OPTION_PATHNAME from _parse_parameters
  # - it may need cleaning up & to have the symlinks dereferenced
  # - this function processes only path prefixes (as opposed to path suffixes)
  #   so slow & careful is perfectly acceptable. it *must* be absolutely 100%
  #   accurate

  # NOTE:
  # - shelling out to certain binaries causes problems with unquoted pathnames
  #   simplest solution is to quote them all until I figure out what makes
  #   things go *BOOM*

  # NOTE:
  # - ranking (3/3)

  # goal #1: (sloppy $_OPTION_PATHNAME)
  # - transform this:
  #   /.////usr//local///bin/////../../../etc/X11/
  # - to this:
  #   /etc/X11

  # goal #2: (symlink dereference)
  # - transform this:
  #   /pub/mirrors/slackware/slackware-current/source/a/aaa_terminfo
  # - into this:
  #   /data/pub/mirrors/slackware/slackware-current/source/l/ncurses

#  _eko_v "\$_OPTION_PATHNAME (start)    : \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (start)    :" \""$_OPTION_PATHNAME\""

  #+ goal #1 +#
  # - sanitize $_OPTION_PATHNAME
  cd -- "$_OPTION_PATHNAME" &>/dev/null
  _OPTION_PATHNAME=$(pwd --)

  # - be tidy. restore the original pwd
  cd -- - &>/dev/null

  # - start (sanitized)
#  _eko_v "\$_OPTION_PATHNAME (sanitized): \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (sanitized):" \""$_OPTION_PATHNAME\""
  #- goal #1 -#

  #+ goal #2 +#
  # - get started
  unset _STRING_PATHNAME

  until [[ "$_OPTION_PATHNAME" == / ]]
  do
    # - destructively deconstruct $_OPTION_PATHNAME for pertinent information
    # - top removed from bottom
    _DIRNAME=$(dirname -- "$_OPTION_PATHNAME")
    _BASENAME=$(basename -- "$_OPTION_PATHNAME")

#    _eko_v "\$_OPTION_PATHNAME (during)   : \"$_OPTION_PATHNAME\""
    _eko_pv "\$_OPTION_PATHNAME (during)   :" \""$_OPTION_PATHNAME\""

    # - dual purpose: object of symbolic link or "" if file is not symbolic link
    _LINKNAME=$(find "$_OPTION_PATHNAME" -maxdepth 0 -printf "%l" 2>/dev/null)

    # - reconstruct
    # - bottom added to top
    # - "-n string" = true if the length of string is non-zero
    if [[ -n $_LINKNAME ]]
    then
#      _eko_v " \$_DIRNAME \$_LINKNAME (link) : \"$_DIRNAME\" \"$_LINKNAME\""
      _eko_pv "\$_DIRNAME \$_LINKNAME (link) :" \""$_DIRNAME\" \"$_LINKNAME\""
      _STRING_PATHNAME=$_LINKNAME/$_STRING_PATHNAME
    else
#      _eko_v " \$_DIRNAME \$_BASENAME        : \"$_DIRNAME\" \"$_BASENAME\""
      _eko_pv "\$_DIRNAME \$_BASENAME        :" \""$_DIRNAME\" \"$_BASENAME\""
      _STRING_PATHNAME=$_BASENAME/$_STRING_PATHNAME
    fi

    # - ascend 1 level
    _OPTION_PATHNAME=$(dirname -- "$_OPTION_PATHNAME")
  done

  # - rebuilt (reconstructed)
#  _eko_v "\$_STRING_PATHNAME (rebuilt)  : \"$_STRING_PATHNAME\""
  _eko_pv "\$_STRING_PATHNAME (rebuilt)  :" \""$_STRING_PATHNAME\""

  # - sanitize $_STRING_PATHNAME
  # - pay attention to the "/" prefix
  cd -- "/$_STRING_PATHNAME" &>/dev/null
  _STRING_PATHNAME=$(pwd --)

  # - be tidy. restore the original pwd
  cd -- - &>/dev/null

  # - assign to $_OPTION_PATHNAME
  _OPTION_PATHNAME=$_STRING_PATHNAME

  # - finish (transformed)
#  _eko_v "\$_OPTION_PATHNAME (finished) : \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (finished) :" \""$_OPTION_PATHNAME\""
  #- goal #2 -#

  _eko_iod "#- _pathname_transform_bruteforce -#"
}

function _pathname_transform_cd_pwd()
{
  _eko_iod "#+ _pathname_transform_cd_pwd +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v

  # variables:
  # _OPTION_PATHNAME
  # _OPTIONS_CD (cd options, not script options)
  # _OPTIONS_PWD (pwd options, not script options)

  # builtins:
  # cd (in combination with pwd, fallback to basename/dirname/find/realpath)
  # pwd (in combination with cd, fallback to basename/dirname/find/realpath)

  # NOTE:
  # - succeeds: _pathname_validate
  # - precedes: _pathname_redundant_check
  # - entry: possibly sloppy $_OPTION_PATHNAME from _parse_parameters
  # - it may need cleaning up & to have the symlinks dereferenced
  # - this function processes only path prefixes (as opposed to path suffixes)
  #   so slow & careful is perfectly acceptable. it *must* be absolutely 100%
  #   accurate

  # NOTE:
  # - ranking (1/3)

  # goal #1: (sloppy $_OPTION_PATHNAME)
  # - transform this:
  #   /.////usr//local///bin/////../../../etc/X11/
  # - to this:
  #   /etc/X11

  # goal #2: (symlink dereference)
  # - transform this:
  #   /pub/mirrors/slackware/slackware-current/source/a/aaa_terminfo
  # - into this:
  #   /data/pub/mirrors/slackware/slackware-current/source/l/ncurses

#  _eko_v "\$_OPTION_PATHNAME (start)    : \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (start)    :" \""$_OPTION_PATHNAME\""

  #+ goal #1 & goal #2 +#
  # - done in two simple (& technically redundant) steps
  # - belt & suspenders. either of $_OPTIONS_CD or $_OPTIONS_PWD would get the
  #   job done
  cd $_OPTIONS_CD -- "$_OPTION_PATHNAME" &>/dev/null
  _OPTION_PATHNAME=$(pwd $_OPTIONS_PWD --)

  # - be tidy. restore the original pwd
  cd -- - &>/dev/null
  #- goal #1 & goal #2 -#

#  _eko_v "\$_OPTION_PATHNAME (finished) : \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (finished) :" \""$_OPTION_PATHNAME\""

  _eko_iod "#- _pathname_transform_cd_pwd -#"
}

function _pathname_transform_realpath()
{
  _eko_iod "#+ _pathname_transform_realpath +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v

  # variables:
  # _OPTION_PATHNAME
  # _OPTIONS_REALPATH (realpath options, not script options)

  # binaries:
  # realpath

  # NOTE:
  # - succeeds: _pathname_validate
  # - precedes: _pathname_redundant_check
  # - entry: possibly sloppy $_OPTION_PATHNAME from _parse_parameters
  # - it may need cleaning up & to have the symlinks dereferenced
  # - this function processes only path prefixes (as opposed to path suffixes)
  #   so slow & careful is perfectly acceptable. it *must* be absolutely 100%
  #   accurate

  # NOTE:
  # - ranking (2/3)

  # goal #1: (sloppy $_OPTION_PATHNAME)
  # - transform this:
  #   /.////usr//local///bin/////../../../etc/X11/
  # - to this:
  #   /etc/X11

  # goal #2: (symlink dereference)
  # - transform this:
  #   /pub/mirrors/slackware/slackware-current/source/a/aaa_terminfo
  # - into this:
  #   /data/pub/mirrors/slackware/slackware-current/source/l/ncurses

#  _eko_v "\$_OPTION_PATHNAME (start)    : \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (start)    :" \""$_OPTION_PATHNAME\""

  #+ goal #1 & goal #2 +#
  # - done in a single step
  # - doublequote only the pathname itself. not the binary or its options
  _OPTION_PATHNAME=$(realpath $_OPTIONS_REALPATH -- "$_OPTION_PATHNAME")
  #- goal #1 & goal #2 -#

#  _eko_v "\$_OPTION_PATHNAME (finished) : \"$_OPTION_PATHNAME\""
  _eko_pv "\$_OPTION_PATHNAME (finished) :" \""$_OPTION_PATHNAME\""

  _eko_iod "#- _pathname_transform_realpath -#"
}

function _pathname_validate()
{
  _eko_iod "#+ _pathname_validate +#"

  # functions:
  # _eko_iod
  # _eko_pv
#  # _eko_v
  # _show_error

  # variables:
  # _OPTION_PATHNAME

  # binaries:
  # find

  # NOTE:
  # - succeeds: _OPTION_PATHNAME assignment
  # - precedes: $_FUNCTION_TRANSFORM
  # - performing brute force tests with "find" since it catches things that
  #   simple tests with bash miss
  # - this function processes only path prefixes (as opposed to path suffixes)
  #   so slow & careful is perfectly acceptable. it *must* be absolutely 100%
  #   accurate
  # - this function is "fall through"
  # ^ if $_OPTION_PATHNAME passes all of the following tests, it's considered
  #   valid

  # - "-z string" = true if the length of string is zero
  if [[ -z $(find "$_OPTION_PATHNAME" -maxdepth 0 2>/dev/null) ]]
  then
    _show_error \""$_OPTION_PATHNAME\" does not exist"
  fi

  # - "-z string" = true if the length of string is zero
  if [[ -z $(find "$_OPTION_PATHNAME" -type d -maxdepth 0 2>/dev/null) ]]
  then
#    _eko_v "            \$_OPTION_PATHNAME: \"$_OPTION_PATHNAME\" (symlink)"
    _eko_pv "\$_OPTION_PATHNAME:" \""$_OPTION_PATHNAME\" (symlink)"
    # - correctly decipher the pathname if the very last element is a symlink
    # - take note of the explicit trailing "/". it's part of the magic
    if [[ -n $(find "$_OPTION_PATHNAME/" -type d -maxdepth 0 2>/dev/null) ]]
    then
      _OPTION_PATHNAME+=/
    else
      _show_error \""$_OPTION_PATHNAME\" is not a directory"
    fi
  fi

  # - "-z string" = true if the length of string is zero
  if [[ -z $(find "$_OPTION_PATHNAME" -type d -maxdepth 0 -readable 2>/dev/null) ]]
  then
    _show_error \""$_OPTION_PATHNAME\" is not readable"
  fi

  # - necessary for hardlinking/unlinking. not necessary for scanning
  # - "-z string" = true if the length of string is zero
  if ( $_BOOLEAN_HARDLINK \
  || $_BOOLEAN_UNLINK ) \
  && [[ -z $(find "$_OPTION_PATHNAME" -type d -maxdepth 0 -writable 2>/dev/null) ]]
  then
    _show_error \""$_OPTION_PATHNAME\" is not writable"
  fi

#  _eko_v "            \$_OPTION_PATHNAME: \"$_OPTION_PATHNAME\" (valid)"
  _eko_pv "\$_OPTION_PATHNAME:" \""$_OPTION_PATHNAME\" (valid)"

  _eko_iod "#- _pathname_validate -#"
}

function _pathnames_scan()
{
  _eko_iod "#+ _pathnames_scan +#"

  # functions:
  # _eko_iod
  # _eko_pv
  # _eko_v (only for testing)

  # variables:
  # $$
  # @
  # PPID
  # _ARRAY_HOLDNAMES (single dimension indexed array)
  # _ARRAY_PATHNAMES (single dimension indexed array)
  # _BOOLEAN_DRYRUN
  # _BOOLEAN_HARDLINK
  # _BOOLEAN_LONG
  # _BOOLEAN_NANOSECONDS
  # _BOOLEAN_RELATIVE
  # _BOOLEAN_STDOUT
  # _BOOLEAN_SUM
  # _BOOLEAN_TIMESTAMP
  # _BOOLEAN_UNLINK
  # _BOOLEAN_VERBOSE
  # _BOOLEAN_XDEV
  # _FUNCTION_SUM (_pathname_md5sum_md5sum _pathname_openssl_md5sum _pathname_openssl_sha1sum _pathname_openssl_sha224sum _pathname_openssl_sha256sum _pathname_openssl_sha384sum _pathname_openssl_sha512sum _pathname_sha1sum_sha1sum _pathname_sha224sum_sha224sum _pathname_sha256sum_sha256sum _pathname_sha384sum_sha384sum _pathname_sha512sum_sha512sum)
  # _MY_GID
  # _MY_UID
  # _OPTIONS_CP (cp options, not script options)
  # _OPTIONS_MV (mv options, not script options)
  # _OPTIONS_READ (read options, not script options)
  # _OPTIONS_READWRITE (find options. not script options)
  # _OPTIONS_UIDGID (find options. not script options)
  # _OPTIONS_UNLINK (find options. not script options)
  # _OPTIONS_XDEV (find options. not script options)
  # _SD_MTIM_HMS (contrivance. not from stat(2))
  # _SD_MTIM_UTC (contrivance. not from stat(2))
  # _SD_MTIM_YMD (contrivance. not from stat(2))
  # _SD_NAME (contrivance. not from stat(2))
  # _ST_DEV
  # _ST_GID
  # _ST_INO
  # _ST_MODE
  # _ST_MTIM_HMS (contrivance. not from stat(2))
  # _ST_MTIM_UTC (contrivance. not from stat(2))
  # _ST_MTIM_YMD (contrivance. not from stat(2))
  # _ST_NAME (contrivance. not from stat(2))
  # _ST_NLINK
  # _ST_SIZE
  # _ST_SUM (contrivance. not from stat(2))
  # _ST_UID
  # _SU_NAME (contrivance. not from stat(2))

  # binaries:
  # cp
  # find
#  # ln
  # mv
  # sort
  # touch

  # builtins:
  # read

  # NOTE:
  # - no need to manipulate $IFS (now supports pathnames containing 0x09 [tab]
  #   & 0x20 [space]. does not support pathnames containing 0x0a [linefeed])
  # - gathers all the required stat(2) information during the scan

  # NOTE:
  # - because of the -readable/-writable magic from "find", only files that
  #   can be unlinked are reported when "-U, --unlink" is specified. this
  #   makes what would have been an incredibly complex task quite simple
  # - additionally, -uid/-gid magic from "find" restricts the possibilities
  #   even further

  # NOTE:
  # - several, but not all, _OPTIONS_* are set up here, others in
  #   "function _binary_validate_setup"

  # NOTE:
  # - if unlinking is interrupted for any reason, the original file will still
  #   be in place. the temporary file will be removed & the parent directory's
  #   timestamp will be restored. cleanup is handled by "function _trap"

  # NOTE:
  # - acquire only _SD_MTIM_* & _SD_NAME from outer find (with -printf)
  # - acquire numerous _ST_* from inner find (with -printf)
  # - refer to stat(2) for full descriptions of _st_* information

  # NOTE:
  # - belt & suspenders:
  #   - outer loop with "find <other options> ! -empty"
  #   - inner loop with "if [[ -n "$_ST_NAME" ]]"
  # - costs nothing for the "! -empty" test & both (empty/"-n") together might
  #   offer a minor speed increase
  # - the "-n" conditional in the inner loop is necessary. a directory might
  #   be "not empty" but contain only non-regular files
  # - related to "-n" in the inner loop: "! -empty" cannot be used here as
  #   valid zero-length files would then be skipped

  # NOTE:
  # - all of what's being done within the inner loop needs to be as
  #   streamlined as possible. the former approach was very expensive timewise
  #   & quite noticeable the larger the filesets became (done?)
  # - tests are ranked by desired speed of operation, so: stdout/long/verbose
  # - code compactness/legiblility deliberately sacrificed for code speed

  # - necessary for hardlinking/unlinking & for scanning (respectively)
  if $_BOOLEAN_HARDLINK \
  || $_BOOLEAN_UNLINK
  then
    _OPTIONS_READWRITE="-readable -writable"
  else
    _OPTIONS_READWRITE="-readable"
  fi

  if ( $_BOOLEAN_HARDLINK \
  || $_BOOLEAN_UNLINK ) \
  && ( [[ $_MY_UID -ne 0 ]] \
  || [[ $_MY_GID -ne 0 ]] )
  then
    # - non-root is restricted to directories to which they have write access
    #   (handled by $_OPTIONS_READWRITE) & only their own files
    #   (handled by $_OPTIONS_READWRITE & $_OPTIONS_UIDGID in concert)
    # - better to be too strict than not strict enough
    _OPTIONS_UIDGID="-uid $_MY_UID -gid $_MY_GID"
  else
    # - root can do anything, write access permitting
    unset _OPTIONS_UIDGID
  fi

  # - multi-link magic
  # - necessary for unlinking. not necessary for hardlinking/scanning
  if $_BOOLEAN_UNLINK
  then
    _OPTIONS_UNLINK="-links +1"
  else
    unset _OPTIONS_UNLINK
  fi

  # - submount magic
  # - optional for hardlinking/scanning/unlinking
  # - $_ST_DEV will be preserved in the sqlite3 db, so hardlinking one or more
  #   filesystems (deliberately including or excluding submounts) with one or
  #   more invocations of "-p, --pathname" should be possible. "-x, --xdev"
  #   itself, though, is an all or nothing option
  if $_BOOLEAN_XDEV
  then
    _OPTIONS_XDEV="-xdev"
  else
    unset _OPTIONS_XDEV
  fi

#  _eko_v "          \$_OPTIONS_READWRITE: \"$_OPTIONS_READWRITE\""
#  _eko_v "             \$_OPTIONS_UIDGID: \"$_OPTIONS_UIDGID\""
#  _eko_v "             \$_OPTIONS_UNLINK: \"$_OPTIONS_UNLINK\""
#  _eko_v "               \$_OPTIONS_XDEV: \"$_OPTIONS_XDEV\""
  _eko_pv "\$_OPTIONS_READWRITE:" \""$_OPTIONS_READWRITE\""
  _eko_pv "\$_OPTIONS_UIDGID:" \""$_OPTIONS_UIDGID\""
  _eko_pv "\$_OPTIONS_UNLINK:" \""$_OPTIONS_UNLINK\""
  _eko_pv "\$_OPTIONS_XDEV:" \""$_OPTIONS_XDEV\""

  # - save the base path, cd to it, reset it to "."
  # - only possible if $_ARRAY_PATHNAMES contains a single pathname. already
  #   tested/trapped in "function _parse_parameters"
  if $_BOOLEAN_RELATIVE
  then
    _ARRAY_HOLDNAMES="$_ARRAY_PATHNAMES"
    cd -- "$_ARRAY_PATHNAMES" &>/dev/null
    _ARRAY_PATHNAMES="."
  fi

  # - default = do not update directory timestamp
  _BOOLEAN_TIMESTAMP=false

  while read $_OPTIONS_READ -- \
  _SD_MTIM_YMD \
  _SD_MTIM_HMS \
  _SD_MTIM_UTC \
  _SD_NAME
  do
    while read $_OPTIONS_READ -- \
    _ST_DEV \
    _ST_INO \
    _ST_MODE \
    _ST_NLINK \
    _ST_UID \
    _ST_GID \
    _ST_SIZE \
    _ST_MTIM_YMD \
    _ST_MTIM_HMS \
    _ST_MTIM_UTC \
    _ST_NAME
    do
      # - "-n string" = true if the length of string is non-zero
      if [[ -n "$_ST_NAME" ]]
      then

        #+ DANGER! WILL ROBINSON! DANGER! this is live code +#
        if ! $_BOOLEAN_DRYRUN \
        && $_BOOLEAN_UNLINK
        then
if $_BOOLEAN_TESTING_01
then
          # 1/8
          # - used in 7/8
          # - this is everything known about the original $_SD_NAME
          _eko_v "1/8: \$_SD_MTIM_YMD: \"$_SD_MTIM_YMD\""
          _eko_v "1/8: \$_SD_MTIM_HMS: \"$_SD_MTIM_HMS\""
          _eko_v "1/8: \$_SD_MTIM_UTC: \"$_SD_MTIM_UTC\""
          _eko_v "1/8: \$_SD_NAME: \"$_SD_NAME\""

          # - this is everything known about the original $_ST_NAME
          _eko_v "1/8: \$_ST_DEV: \"$_ST_DEV\""
          _eko_v "1/8: \$_ST_INO: \"$_ST_INO\""
          _eko_v "1/8: \$_ST_MODE: \"$_ST_MODE\""
          _eko_v "1/8: \$_ST_NLINK: \"$_ST_NLINK\""
          _eko_v "1/8: \$_ST_UID: \"$_ST_UID\""
          _eko_v "1/8: \$_ST_GID: \"$_ST_GID\""
          _eko_v "1/8: \$_ST_SIZE: \"$_ST_SIZE\""
          _eko_v "1/8: \$_ST_MTIM_YMD: \"$_ST_MTIM_YMD\""
          _eko_v "1/8: \$_ST_MTIM_HMS: \"$_ST_MTIM_HMS\""
          _eko_v "1/8: \$_ST_MTIM_UTC: \"$_ST_MTIM_UTC\""
          _eko_v "1/8: \$_ST_NAME: \"$_ST_NAME\""
fi
          # - be as unique as possible. why such a convoluted file name?
          # - 1: the base name *is* the original file name
          # - 2: "scanfs" to make it easy to find stray temporary files in
          #      case disaster strikes
          # - 3: "$_MY_UID" for finger pointing :)
          # - 4: "$_MY_GID" for additional finger pointing :)
          # - 5: "$PPID" for a degree of uniqueness coupled with the
          #      following:
          # - 6: "$$" for an additional degree of uniqueness in case the user
          #      is *ahem* unwise enough to process the same directory
          #      hierarchy simultaneously
          _SU_NAME="${_ST_NAME}.scanfs.$_MY_UID:$_MY_GID.$PPID.$$"
if $_BOOLEAN_TESTING_01
then
          # 2/8
          # - $_SU_NAME all dressed up with no place to go
          _eko_v "2/8: \$_SU_NAME: \"$_SU_NAME\""
fi

          # - copy the original file (with various options) to a unique file
          # - take note of what is & what is not doublequoted
if $_BOOLEAN_TESTING_01
then
          # 3/8 (eko precedes action)
          _eko_v "3/8: \"cp $_OPTIONS_CP -- \"$_ST_NAME\" \"$_SU_NAME\""
fi
          cp $_OPTIONS_CP -- "$_ST_NAME" "$_SU_NAME"

          # - get stat(2) info of the newly created unique file, save
          #   everything as _ST_* (except for _ST_NAME itself). this/these
          #   (whatever) will be used in the long & verbose reports
          read $_OPTIONS_READ -- \
          _ST_DEV \
          _ST_INO \
          _ST_MODE \
          _ST_NLINK \
          _ST_UID \
          _ST_GID \
          _ST_SIZE \
          _ST_MTIM_YMD \
          _ST_MTIM_HMS \
          _ST_MTIM_UTC \
          < \
          <(find "$_SU_NAME" \
          -type f \
          -maxdepth 0 \
          -printf "%D %i %M %n %U %G %s %TY-%Tm-%Td %TH:%TM:%TS %TZ\n" 2>/dev/null)
if $_BOOLEAN_TESTING_01
then
          # 4/8
          # - this is everything known about the newly created $_SU_NAME
          # - take careful note: _ST_* & _SU_NAME below. this is deliberate as
          #   what is currently _SU_NAME will become _ST_NAME in 5/8
          _eko_v "4/8: \$_ST_DEV: \"$_ST_DEV\""
          _eko_v "4/8: \$_ST_INO: \"$_ST_INO\""
          _eko_v "4/8: \$_ST_MODE: \"$_ST_MODE\""
          _eko_v "4/8: \$_ST_NLINK: \"$_ST_NLINK\""
          _eko_v "4/8: \$_ST_UID: \"$_ST_UID\""
          _eko_v "4/8: \$_ST_GID: \"$_ST_GID\""
          _eko_v "4/8: \$_ST_SIZE: \"$_ST_SIZE\""
          _eko_v "4/8: \$_ST_MTIM_YMD: \"$_ST_MTIM_YMD\""
          _eko_v "4/8: \$_ST_MTIM_HMS: \"$_ST_MTIM_HMS\""
          _eko_v "4/8: \$_ST_MTIM_UTC: \"$_ST_MTIM_UTC\""
          _eko_v "4/8: \$_SU_NAME: \"$_SU_NAME\""
fi

          # - move the newly created unique file into place, overwriting the
          #   original file
          # - take note of what is & what is not doublequoted
if $_BOOLEAN_TESTING_01
then
          # 5/8 (eko precedes action)
          _eko_v "5/8: \"mv $_OPTIONS_MV -- \"$_SU_NAME\" \"$_ST_NAME\""
fi
          mv $_OPTIONS_MV -- "$_SU_NAME" "$_ST_NAME"

          # - since at least one file was manipulated in the current
          #   directory, the directory's timestamp will need to be restored
          # - flag it now, restore it immediately after processing the current
          #   directory
          _BOOLEAN_TIMESTAMP=true
if $_BOOLEAN_TESTING_01
then
          # 6/8
          _eko_v "6/8: \$_BOOLEAN_TIMESTAMP: \"$_BOOLEAN_TIMESTAMP\""
fi
        fi
        #- DANGER! WILL ROBINSON! DANGER! this is live code -#

        if ! $_BOOLEAN_NANOSECONDS
        then
          # NOTE:
          # - preserve nanoseconds for (optional) display
          # - explicitly remove nanoseconds for the sqlite3 db
          _ST_MTIM_HMS=${_ST_MTIM_HMS/.*/}

          # - this seems to be the most efficient method time-wise
          # - dump $_ST_MTIM_HMS to the sqlite3 db here
        #else
          # - dump ${_ST_MTIM_HMS/.*/} to the sqlite3 db here
        fi

        if $_BOOLEAN_STDOUT
        then
          if $_BOOLEAN_SUM
          then
            # - generate *sum of the file (full or $_OPTION_SUM_SIZE)
            $_FUNCTION_SUM
            printf "%s  %s\n" $_ST_SUM "$_ST_NAME"
          else
            printf "%s\n" "$_ST_NAME"
          fi
        elif $_BOOLEAN_LONG
        then
          if $_BOOLEAN_SUM
          then
            # - generate *sum of the file (full or $_OPTION_SUM_SIZE)
            $_FUNCTION_SUM
            printf "%4s %10s %s %4s %4s %-3s %14s %s %s %s %s %s\n" \
            $_ST_DEV $_ST_INO $_ST_MODE $_ST_NLINK $_ST_UID $_ST_GID \
            $_ST_SIZE $_ST_MTIM_YMD $_ST_MTIM_HMS $_ST_MTIM_UTC \
            $_ST_SUM \
            "$_ST_NAME"
          else
            printf "%4s %10s %s %4s %4s %-3s %14s %s %s %s %s\n" \
            $_ST_DEV $_ST_INO $_ST_MODE $_ST_NLINK $_ST_UID $_ST_GID \
            $_ST_SIZE $_ST_MTIM_YMD $_ST_MTIM_HMS $_ST_MTIM_UTC \
            "$_ST_NAME"
          fi
        elif $_BOOLEAN_VERBOSE
        then
          if $_BOOLEAN_SUM
          then
            # - generate *sum of the file (full or $_OPTION_SUM_SIZE)
            $_FUNCTION_SUM
            printf "\n%30s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n" \
            \$_ST_DEV: \""$_ST_DEV\"" \
            \$_ST_INO: \""$_ST_INO \"" \
            \$_ST_MODE: \""$_ST_MODE\"" \
            \$_ST_NLINK: \""$_ST_NLINK\"" \
            \$_ST_UID: \""$_ST_UID\"" \
            \$_ST_GID: \""$_ST_GID\"" \
            \$_ST_SIZE: \""$_ST_SIZE\"" \
            \$_ST_MTIM: \""$_ST_MTIM_YMD $_ST_MTIM_HMS $_ST_MTIM_UTC\"" \
            \$_ST_SUM: \""$_ST_SUM\"" \
            \$_ST_NAME: \""$_ST_NAME\""
          else
            printf "\n%30s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n %29s %s\n" \
            \$_ST_DEV: \""$_ST_DEV\"" \
            \$_ST_INO: \""$_ST_INO\"" \
            \$_ST_MODE: \""$_ST_MODE\"" \
            \$_ST_NLINK: \""$_ST_NLINK\"" \
            \$_ST_UID: \""$_ST_UID\"" \
            \$_ST_GID: \""$_ST_GID\"" \
            \$_ST_SIZE: \""$_ST_SIZE\"" \
            \$_ST_MTIM: \""$_ST_MTIM_YMD $_ST_MTIM_HMS $_ST_MTIM_UTC\"" \
            \$_ST_NAME: \""$_ST_NAME\""
          fi
        fi

      fi
    done \
    < \
    <(find "$_SD_NAME" \
    -type f \
    -maxdepth 1 \
    $_OPTIONS_READWRITE \
    $_OPTIONS_UIDGID \
    $_OPTIONS_UNLINK \
    $_OPTIONS_XDEV \
    -printf "%D %i %M %n %U %G %s %TY-%Tm-%Td %TH:%TM:%TS %TZ %p\n" 2>/dev/null \
    | sort --key=11)

    #+ DANGER! WILL ROBINSON! DANGER! this is live code +#
    # - if one or more files were manipulated. the parent directory's
    #   timestamp will need restoration
    # - no need for additional boolean logic because the only way files
    #   *could* be manipulated is if the parent directory is writable
    # - there is a single (known) special case where attempting to restore the
    #   parent directory's timestamp will fail. script run as non-root.
    #   unlinking files in a directory that is itself mode 1777 (drwxrwxrwt) &
    #   owned by someone other than oneself. hence the "2>/dev/null" below
    if $_BOOLEAN_TIMESTAMP
    then
      # - take careful note: $_SD_* & not $_ST_* or $_SU_*
if $_BOOLEAN_TESTING_01
then
      # 7/8 (eko precedes action)
      _eko_v "7/8: \"touch --date=\"$_SD_MTIM_YMD $_SD_MTIM_HMS $_SD_MTIM_UTC\" \"$_SD_NAME\" 2>/dev/null"
fi
      touch --date="$_SD_MTIM_YMD $_SD_MTIM_HMS $_SD_MTIM_UTC" "$_SD_NAME" 2>/dev/null

      # - reset the flag for the next iteration
      _BOOLEAN_TIMESTAMP=false
if $_BOOLEAN_TESTING_01
then
      # 8/8
      _eko_v "8/8: \$_BOOLEAN_TIMESTAMP: \"$_BOOLEAN_TIMESTAMP\""
fi
    fi
    #- DANGER! WILL ROBINSON! DANGER! this is live code -#

  done \
  < \
  <(find "${_ARRAY_PATHNAMES[@]}" \
  -type d \
  ! -empty \
  $_OPTIONS_READWRITE \
  $_OPTIONS_XDEV \
  -printf "%TY-%Tm-%Td %TH:%TM:%TS %TZ %p\n" 2>/dev/null \
  | sort --key=4)

  # - restore the base path
  if $_BOOLEAN_RELATIVE
  then
    _ARRAY_PATHNAMES="$_ARRAY_HOLDNAMES"

    # - be tidy. restore the original pwd
    cd -- - &>/dev/null
  fi

  _eko_iod "#- _pathnames_scan -#"
}

function _show_error()
{
  _eko_iod "#+ _show_error +#"

  # functions:
  # _eko_iod

  # variables:
  # @

  # - output to stderr, not stdout
  # - be explicit for clarity
  echo "Error: $@" 1>&2

  _eko_iod "#- _show_error -#"

  exit 1
}

function _show_help()
{
  _eko_iod "#+ _show_help +#"

  # functions:
  # _eko_iod

  # variables:
  # (none)

  echo "Provide at least 1 parameter: <PathName> [OPTION] [[OPTION]]

Mandatory parameter:
  -p, --pathname      Pathname(s) to scan

Optional parameters:
  -D, --dry-run       Perform a trial run of the specified action
  -E, --error         (TODO. unimplemented)
  -H, --hardlink      Link duplicate files (TODO. unimplemented)
  -N, --non-sparse    Explicitly force non-sparse copies when unlinking files
  -S, --sparse        Explicitly force sparse copies when unlinking files
  -U, --unlink        Unlink previously hardlinked files
  -d, --debug         Display debugging information (function names/entry/exit)
  -l, --long          Display pathname listings in a format similar to \""ls -in\""
  -n, --nanoseconds   Display nanoseconds in long & verbose reports
  -r, --relative      Display relative instead of absolute pathnames
  -v, --verbose       Display verbose information (variable names/contents)
  -x, --xdev          Do not descend directories on other filesystems
  -m, --md5sum        Generate an md5sum for each file
  -1, --sha1sum       Generate an sha1sum for each file
  -224, --sha224sum   Generate an sha224sum for each file
  -256, --sha256sum   Generate an sha256sum for each file
  -384, --sha384sum   Generate an sha384sum for each file
  -512, --sha512sum   Generate an sha512sum for each file
  -s, --size          Specify the maximum \""head\"" size of each file to *sum
  -?, -h, --help      Display this help text, useful as it is
  -W, -w, --warning   Display big fat warning. don't say I didn't tell you!

There are 3 basic types of parameters:
           additive: \"-p\"
             toggle: \"-D -E -H -N -S -U -d -l -n -r -v -x\"
  single invocation: \"-m -1 -224 -256 -384 -512, -s\"

Note:
  Globs are supported with \"-p, --pathname\". Refer to bash(1) section
  \"Pattern Matching\" for specifics"

  _eko_iod "#- _show_help -#"

  exit 0
}

function _show_warning()
{
  _eko_iod "#+ _show_warning +#"

  # functions:
  # _eko_iod

  # variables:
  # (none)

  echo "
WARNING!

These apply only to hardlinking & unlinking. Scanning is purely read-only.

Since kernel 2.5.48, the stat(2) structure supports timestamps with
\"second.nanosecond\" resolution. If timestamp accuracy to the nanosecond is
a requirement on your system, DO NOT USE THIS SCRIPT. In order to function,
this script deliberately ignores nanoseconds in timestamps in many, but not
all, of its actions.

DO NOT under ANY circumstances whatsoever modify anything within the specified
filesystem paths while they're being processed.
At best, nothing undesired will occur.
At worst, old/new files will be overwritten by their new/old counterparts.
This holds especially true for files that have previously been hardlinked.
Consider: files with all of their hardlinked counterparts \"inside\" the paths
being processed & also files with some of their hardlinked counterparts
\"inside\" & \"outside\" the paths being processed.
The behaviour is, by definition, unpredictable.

TL;DR version: You break it, you get to keep both halves
"

  _eko_iod "#- _show_warning -#"

  exit 0
}

#- function definitions here -#

#+ start here +#

# functions:
# _parse_parameters

# variables:
# @

_parse_parameters "$@"

#- start here -#

#- marker eof -#
exit 0
